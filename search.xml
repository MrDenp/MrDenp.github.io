<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F11%2F29%2FCanvas%2F</url>
    <content type="text"><![CDATA[title: Canvasdate: 2018-11-21 09:15:54categories: - canvas绘制海报 tags: - canvas description:canvas 在现代开发中的应用越来越多，比如说 将页面绘制成海报并保存成图片，这样的需求越来越多。还有 使用 canvas 绘制数据结构图，尤其是在大数据分析的项目中，canvas 几乎成为表现数据的一种常态。最近公司的项目中多处用到了 canvas 。故此，留下此篇文章以作备忘。 Canvas什么是canvas？ &lt;canvas&gt; 是 HTML5 新增的元素，可用于通过使用 JavaScript 中的脚本来绘制图形。例如，它可以用于绘制图形、制作照片、创建动画，甚至可以进行实时视频处理或渲染。 注意 这里的canvas只是一个画布，绘图功能还是需要使用JS语言 一句话总结什么是 canvas什么是 Canvas？Canvas 是为了解决 Web 页面中只能显示静态图片这个问题而提出的，一个可以使用 JavaScript 等脚本语言向其中绘制图像的 HTML 标签。 canvas 可以实现哪些需求绘制图表 绘制图表是canvas应用最多的 因为 Canvas 通过 JavaScript 可以动态传入参数绘制图形，所以我们可以使用 Canvas 作为容器，通过 JavaScript 动态传入的参数将数据以图表的形式显示出来。 小游戏 基本上所有的 HTML5 游戏引擎都是基于 Canvas 开发的 首先是因为 Canvas 不需要借助任何插件就可以在网页中绘图。并且其强大的绘图 API 可以操纵页面上的每一个元素。 活动页面 大转盘抽奖 刮刮乐等等效果 小特效 粒子特效canvas基础创建画布1&lt;canvas id="canvas" width="400" height="400"&gt;&lt;/canvas&gt; 初始化画布//初始化画布 var canvas = document.getElementById("canvas"); var context = canvas.getContext("2d"); //开始绘制 beginPath() 开始路径绘制 closePath() 结束路径绘制 context.beginPath(); context.arc(100, 100, 50, 0, Math.PI * 2, true); context.closePath(); context.fillStyle = 'rgb(255,255,255)'; context.fill(); 绘制图形 arc(x, y, radius, startAngle, endAngle, anticlockwise) rect(x, y, width, height) 绘制矩形 fillRect(x, y, width, height) 绘制填充矩形 strokeRect(x, y, width, height) 绘制描边矩形 clearRect(x, y, width, height) 清除指定矩形区域 stroke() 描边 fill() 填充 moveTo(x, y) 绘制不连续的路径 lineTo(x, y) 绘制线 quadraticCurveTo(cp1x, cp1y, x, y) 绘制 二次贝塞尔曲线 cp1x,cp1y为一个控制点 x ,y 为结束点 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) 绘制 三次贝塞尔曲线 cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。添加样式 fillStyle = color 设置图形的填充颜色。 strokeStyle = color 设置图形轮廓的颜色。 globalAlpha = transparencyValue 这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。 lineWidth = value 设置线条宽度 lineCap = type 设置线条末端样式 lineJoin = type 设定线条与线条间接合处的样式 lineWidth = value 线宽 lineWidth = value 线宽通过 canvas 实现过哪些案例]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入 JavaScript 第一篇 this 之 ‘绑定五式’]]></title>
    <url>%2F2018%2F11%2F29%2Fthis%2F</url>
    <content type="text"><![CDATA[this 绑定 归纳为五种 默认绑定（严格/非严格模式） 隐式绑定 显示绑定 new绑定 箭头函数 2-1.默认绑定 独立函数调用 : 可以把默认绑定看作是一种无法应用其他绑定规则时的默认绑定属性，this 指向全局对象（window） 严格模式下 ： 严格模式下的this不能默认绑定全局对象，它会指向 undefined 。只有在函数 运行 在非严格模式下，默认绑定才能绑定在 全局对象 上。在严格模式下 调用 函数则不会影响默认绑定。12345678910111213141516171819function foo() &#123; "use strict"; console.log(this.a);&#125;var a = 2;foo();//此处抛出 语法错误 TpyeError: Cannot read property 'a' of undefined;// ---------------------------------------------------------------function foo2() &#123; console.log(this.a2);&#125;var a2 = 2;(function() &#123; "use strict"; foo2();&#125;)();// 2 2-2 隐式绑定 当函数引用有 上下文对象 时，隐式绑定规则会把函数中的this绑定到这个上下对象。对象属性引用中只有上一层或者最后一层在调用中起作用。 12345678910function foo() &#123; console.log(this.a)&#125;var obj = &#123; a:2, foo&#125;;obj.foo(); //2var boo = obj.foo;boo();//此处 为undefined 上面代码执行分析 obj.foo()直接执行时 this 绑定在obj对象身上，而当obj.foo被存在全局变量 boo 身上时，此时相当于在全局环境下声明了一个函数，当执行此函数时，this 指向全局对象，(全局对象身上并没有a属性，此处注意 所有的原型搜寻都是向上查找) 隐式绑定会有丢失this绑定的情况 一般发生在把函数当做参数传递的时候，这个时候就是一种隐式赋值，回调函数丢失this是非常常见的。 2-3 显示绑定通过 call(..) 或者 apply(..) 方法。第一个参数是一个对象，在调用函数时将这个对象绑定到this。因为直接指定this的绑定对象，称之为显示绑定。1234567function foo() &#123; console.log(this.a);&#125;var obj = &#123; a:2&#125;foo().call(obj);// 2 显示绑定无法解决丢失绑定问题 2-4 new 绑定 在JS中，构造函数 只是使用 new 操作符时被调用的 普通 函数，他们不属于某个类，也不会实例化一个类。 包括内置对象函数（比如Number(..)）在内的所有函数都可以用new来调用，这种函数调用被称为构造函数调用。 实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 使用new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1、创建（或者说构造）一个新对象 2、这个新对象会被执行[[Prototype]]连接 3、这个新对象会绑定到函数调用的this 4、如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo(2); // bar和foo(..)调用中的this进行绑定console.log( bar.a ); // 2 2-5 箭头函数ES6新增一种特殊函数类型：箭头函数，箭头函数无法使用上述四条规则，而是根据外层（函数或者全局）作用域（词法作用域）来决定this。 123456789101112131415161718function foo() &#123; // 返回一个箭头函数 return (a) =&gt; &#123; // this继承自foo() console.log( this.a ); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;var bar = foo.call( obj1 );bar.call( obj2 ); // 2，不是3！]]></content>
      <categories>
        <category>JavaScript深入</category>
        <category>this</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画效果卡顿？那是你没了解这点...]]></title>
    <url>%2F2018%2F11%2F20%2Fanimate%2F</url>
    <content type="text"><![CDATA[问题 首先需要了解的是性能问题是如何造成的，为什么会有性能问题。（不要说手机不好，这样对方听起来就是，你在找借口？） 浏览器的回流重绘 什么情况下浏览器会将页面进行回流重绘？ 计算每个 DOM 元素 在最终屏幕上显示的大小和位置。由于 web 页面的元素布局是相对的，所以其中任意一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫 reflow (回流)。 动画过程中会特别占用cpu 而cpu占用率过高，自然出现了卡顿 大多数设备的刷新频率是 60 次/秒，那么也就是说浏览器对每一帧动画的渲染 需要在 1000/60 = 16.6ms,超出这个时间，页面的渲染就会出现卡顿现象，影响用户体验.解决只需一行代码123.div&#123; transform: translate3d(0, 0, 0);&#125; 虽然只用了这么一行代码，我们也需要知道原理是什么。 这个其实是利用了translateZ 开启了GPU 加速.但是物极必反，若GPU占用过高也会造成性能问题。SO 只需要在页面动画卡顿的地方使用就好。]]></content>
      <categories>
        <category>CSS动画</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>GPU加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Phaser H5游戏框架]]></title>
    <url>%2F2018%2F10%2F16%2FPhaserGameFrameWork%2F</url>
    <content type="text"><![CDATA[Phaser 框架 文档 💎 | http://www.phaserengine.com/docs phaser.min.js 💎 | https://github.com/photonstorm/phaser/releases/download/v2.4.6/phaser.min.js 基础操作 不多说废话 最直观的就是代码加注释 快速理解 快速查找知识点1]]></content>
      <categories>
        <category>游戏框架</category>
        <category>Phaser</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些小效果的实现]]></title>
    <url>%2F2018%2F10%2F12%2Fdemo%2F</url>
    <content type="text"><![CDATA[效果合集纯css实现’融合‘ filter 废话不多说直接上代码 123456789101112131415161718192021222324252627282930313233343536&lt;style type="text/css"&gt; .box &#123; filter: contrast(20); background: #fff; padding: 10px; &#125; .left, .right &#123; display: inline-block; width: 100px; height: 100px; border-radius: 50%; filter: blur(6px); &#125; .left &#123; background-color: black; position: absolute; left: 0; animation: move 10s infinite alternate; &#125; @keyframes move &#123; 100% &#123; left: 250px; &#125; &#125; .right &#123; background-color: #ff792e; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 波浪动画 css实现 123456789101112131415161718192021&lt;svg width="200px" height="200px" version="1.1" xmlns="http://www.w3.org/2000/svg"&gt; &lt;text class="liquidFillGaugeText" text-anchor="middle" font-size="42px" transform="translate(100,120)" style="fill: #000"&gt;50.0%&lt;/text&gt; &lt;!-- Wave --&gt; &lt;g id="wave"&gt; &lt;path id="wave-2" fill="rgba(154, 205, 50, .8)" d="M 0 100 C 133.633 85.12 51.54 116.327 200 100 A 95 95 0 0 1 0 100 Z"&gt; &lt;animate dur="5s" repeatCount="indefinite" attributeName="d" attributeType="XML" values="M0 100 C90 28, 92 179, 200 100 A95 95 0 0 1 0 100 Z; M0 100 C145 100, 41 100, 200 100 A95 95 0 0 1 0 100 Z; M0 100 C90 28, 92 179, 200 100 A95 95 0 0 1 0 100 Z"&gt;&lt;/animate&gt; &lt;/path&gt; &lt;/g&gt; &lt;circle cx="100" cy="100" r="80" stroke-width="10" stroke="white" fill="transparent"&gt;&lt;/circle&gt; &lt;circle cx="100" cy="100" r="90" stroke-width="20" stroke="yellowgreen" fill="none" class="percentage-pie-svg"&gt;&lt;/circle&gt;&lt;/svg&gt;&lt;style&gt;.css-live-wrap &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>小效果</category>
      </categories>
      <tags>
        <tag>css js 效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发者调试面板 -- vConsole]]></title>
    <url>%2F2018%2F09%2F29%2Fdebug-plug%2F</url>
    <content type="text"><![CDATA[#Vconsole 安装1.下载模块 使用 npm 安装1npm install vconsole 然后复制 dist/vconsole.min.js 到自己的项目中。 2.引入模块 在vue中下载安装包后 可以在main.js中引入12import Vconsole from 'vconsole';const vConsole = new Vconsole(); 在HTML里引入（H5）123456&lt;head&gt; &lt;script src="path/to/vconsole.min.js"&gt;&lt;/script&gt; &lt;script&gt; var vConsole = new VConsole(); &lt;/script&gt;&lt;/head&gt; 在使用AMD/CMD规范中使用12var VConsole = require('path/to/vconsole.min.js');var vConsole = new VConsole(); 3.使用初始化 &amp; 配置12 var vConsole = new VConsole(option);//option 是一个选填的 object 对象 使用 setOption() 来更新 option：123vConsole.setOption('maxLogNumber', 5000);// 或者：vConsole.setOption(&#123;maxLogNumber: 5000&#125;); vConsole.option 键名 类型 可选 默认值 描述 defaultPlugins Array true [‘system’, ‘network’, ‘element’, ‘storage’] 需要自动初始化并加载的内置插件。 onReady Function true 回调方法，当 vConsole 完成初始化并加载完内置插件后触发。 onClearLog Function true 回调方法，点击 Log 或 System 面板的 “Clear” 按钮后触发。 maxLogNumber Number true 1000 超出上限的日志会被自动清除。 disableLogScrolling Boolean true 若为 false，有新日志时面板将不会自动滚动到底部。]]></content>
      <tags>
        <tag>插件</tag>
        <tag>调试</tag>
        <tag>vConsole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios 的封装]]></title>
    <url>%2F2018%2F08%2F08%2Faxios%2F</url>
    <content type="text"><![CDATA[一、axios的封装 在vue项目中，和后台交互数据主要是用的axios这个库，它是基于promise的http库，可以运行在浏览器端和node.js中。它有很多优秀的特性，例如拦截数据请求和响应、取消请求、转换json、客户端防御XSRF等等。 安装1npm install axios; // 安装axios 引入既然考虑到是封装这个请求的功能模块，我在项目的src目录中新建了一个request文件夹，里面放着两个JS文件，http.js 、api.js。http.js文件用来封装 axios ，api.js 用来统一管理接口。 http.js123456//首先需要引入axios 包import axios from 'axios';//引入qs模块，用来序列化post类型的数据import qs from 'qs'// 引入项目中的提示框组件，可以自己写也可以用UI 组件import &#123; Toast &#125; from 'vant' 环境的切换项目的环境会有开发环境、测试环境、生产环境。SO 这里用node的环境变量来匹配我们的默认接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址。 1234567891011// 环境的切换if (process.env.NODE_ENV == 'development') &#123; //开发 axios.defaults.baseURL = 'https://www.baidu.com';&#125; else if (process.env.NODE_ENV == 'debug') &#123; //测试 axios.defaults.baseURL = 'https://www.ceshi.com';&#125;else if (process.env.NODE_ENV == 'production') &#123; //生产 axios.defaults.baseURL = 'https://www.production.com';&#125; 设置请求超时通过axios.defaults.timeout设置默认的请求时间。如果请求时间超出，使用提示框提示用户请求超时，请刷新页面等等操作。 post请求头的设置post请求的时候，我们需要加上一个请求头，所以在这里可以进行一个默认的设置。即：设置默认请求头为 application/x-www-from-urlencoded;charset=UTF-8 1axios.defaults.headers.post['Content-Type'] = 'application/x-www-urlencoded;charset=UTF-8'; 请求拦截在发送请求前可以进行一个请求的拦截，为什么要拦截请求呢？因为在很多时候我们要判断用户是否登录，或者是post请求时，强制序列化请求数据。这个时候我们可以在请求被发送之前进行一个拦截，从而进行我们想要做的操作。 123456789101112131415161718192021222324 // 先导入vuex,因为我们要使用到里面的状态对象 // vuex的路径根据自己的路径去写 import store from &apos;@/store/index&apos;; // 请求拦截器axios.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; &#123; return Promise.error(error); &#125;)``` &gt; 这里需要特别说一下token ，一般是在登录完成之后，将用户的 token 保存在localStorage 或者 cookies 里，然后用户每次在进入页面的时候(即在main.js中)，会首先从本地存储中读取token,如果token存在说明用户已经登录过，则跟新vuex中的token的状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。在处理一些不需要登录的在后台接口去做判断就好了，我们带或不带都可以。## 响应的拦截响应的拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想，如果后台返回的状态码是200，则正常返回数据，否则根据错误的状态码类型进行一些错误处理，其实这里主要就是进行了统一的错误处理和登录与否是否登录信息过期的一个操作。 // 响应拦截器 axios.interceptors.response.use( response =&gt; { // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) { return Promise.resolve(response); } else { return Promise.reject(response); } }, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 error =&gt; { if (error.response.status) { switch (error.response.status) { // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace({ path: &apos;/login&apos;, query: { redirect: router.currentRoute.fullPath } }); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast({ message: &apos;登录过期，请重新登录&apos;, duration: 1000, forbidClick: true }); // 清除token localStorage.removeItem(&apos;token&apos;); store.commit(&apos;loginSuccess&apos;, null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; { router.replace({ path: &apos;/login&apos;, query: { redirect: router.currentRoute.fullPath } }); }, 1000); break; // 404请求不存在 case 404: Toast({ message: &apos;网络请求不存在&apos;, duration: 1500, forbidClick: true }); break; // 其他错误，直接抛出错误提示 default: Toast({ message: error.response.data.message, duration: 1500, forbidClick: true }); } return Promise.reject(error.response); } }, }); 12345678910111213141516171819## 封装get方法和post方法```javascript /** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */ export function get(url, params)&#123; return new Promise((resolve, reject) =&gt;&#123; axios.get(url, &#123; params: params &#125;).then(res =&gt; &#123; resolve(res.data); &#125;).catch(err =&gt;&#123; reject(err.data) &#125;) &#125;);&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex -状态管理-]]></title>
    <url>%2F2018%2F07%2F16%2FVuex%2F</url>
    <content type="text"><![CDATA[VUEX 状态管理概述 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式.它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. 状态管理包括以下几个部分： state,驱动应用的数据源 view,以声明的方式将 state 映射到视图上 actions，响应在 view 上的用户输入导致的状态变化 大概了解了vuex状态管理，那什么时候该用 Vuex ？ 其实在比较简单的单页vue应用中,用状态管理是非常没必要的,这只会加重vue单页应用的复杂度,让整个项目更加繁琐冗余.所以在中大型项目中使用状态管理是最好的选择,这样可以让整个项目的管理便于管理. 废话不多说，从代码中实践才能出真理（ps：这是我从事开发这个行业以来总结出来的一句话，不喜勿喷~~） 如何使用首先是要使用这个vuex我们需要通过 npm 下载这个包 npm install vuex –save 安装完成就需要在项目结构中创建一个文件夹管理123456789101112131415- build- config- node_modules- src - assets - components - router - store /* 存放状态管理所有文件 */ - actions.js - getters.js - mutations.js - store.js /* 需要在main.js引入的模块 */ - App.vue - main.js- static 现在开始写vuex中几个js文件注意：写之前先把vuex注入整个项目工程中123456789// main.jsimport store from './store/index'new Vue(&#123; el: '#app', router, Store,//在这里注入状态管理 components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//./store/index.js import Vue from 'vue' import Vuex from 'vuex' import mutations from './mutations' import getters from './getters' import actions from './actions' Vue.use(Vuex) // 初始化一些常用数据，根据vue的理念，使用到的数据都必须先进行初始化设置。 let state = &#123; // 对话框 dialog: false, // 侧边栏 sidebar: &#123; open: false, docked: true &#125;, // 用户主页 personindex: false, // 搜索框 search: false, // 导航栏标题 headerTitle: 'Message', // 初始化基础数据 data: &#123; self: &#123;&#125;, friends: [] &#125;, // ajax请求数据是否结束 isAjax: false, // 当前被选中或者在聊天中的friend的_id activeId: 0, // 聊天队列，这里为每个朋友添加了一个聊天队列，偷懒写法，如果有需要可以改成动态添加 // _id是作为聊天队列的标记，list是聊天内容，list里的数据格式&#123;_id:xx, message:xxx&#125;,组件内会根据_id来将对话插入 // 到左边，还是右边，判断message是自己还是ai发出的 messageList: [ &#123; _id: 1, list: [&#123; _id: 1, message: '你可以和我聊天', time: '4:28' &#125;] &#125;, &#123; _id: 2, list: [&#123; _id: 2, message: '我会讲笑话哦', time: '9:50' &#125;] &#125;, &#123; _id: 3, list: [&#123; _id: 3, message: '请问你要来点兔子吗', time: '3:12' &#125;] &#125; ], // 消息队列副本，由于没有数据库，所以采用这样折中的方法 messageListFB: [ &#123; _id: 1, list: [&#123; _id: 1, message: '你可以和我聊天', time: '4:28' &#125;] &#125;, &#123; _id: 2, list: [&#123; _id: 2, message: '我会讲笑话哦', time: '9:50' &#125;] &#125;, &#123; _id: 3, list: [&#123; _id: 3, message: '请问你要来点兔子吗', time: '3:12' &#125;] &#125; ] &#125; // 导出一个新生成的Store对象 export default new Vuex.Store(&#123; state, mutations, actions, getters &#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 // actions.js// actions里存放的是异步操作// 由于vuex中的state的变更只能由mutations进行操作，所以actions不直接进行数据操作，而是调用mutations方法// 以下出现的that都是vue实例对象，因为把axios绑定在了Vue原型上，vuex无法调用，所以这里需要传入thisconst actions = &#123; // 异步获取基础数据 // 这里使用了es7的async函数，相当于封装了promis的generator getAllData: async (&#123; commit &#125;, that) =&gt; &#123; // 声明变量用来存放之后获得的数据 let self = &#123;&#125; let friends = &#123;&#125; await that.$http.get('/api/self') .then((&#123; data &#125;) =&gt; &#123; self = data.data &#125;) await that.$http.get('/api/friends') .then((&#123; data &#125;) =&gt; &#123; friends = data.data &#125;) commit('getData', &#123; self, friends &#125;) &#125;, // 聊天机器人 sendValue: async (&#123; commit &#125;, &#123; _id, message, that &#125;) =&gt; &#123; // 声明一个变量用来储存等下ajax获取的数据 let robotData = '' // 处理输入的内容，设置self为true，作为一个标记。 commit('changeList', &#123; self: true, _id, message &#125;) // 进行ajax请求，此处的that是从组件内传来的对象this await that.$http.get('/api/robotapi', &#123; params: &#123; message, id: _id &#125; &#125;).then(res =&gt; &#123; // 将获取到的数据赋值给先前设置的变量 robotData = JSON.parse(res.data.data) &#125;) // 判断获取到的数据类型，在进行对应操作 if (robotData.code === 100000) &#123; commit('changeList', &#123; _id, message: robotData.text &#125;) &#125; else if (robotData.code === 200000) &#123; let data = robotData.text + robotData.url commit('changeList', &#123; _id, message: data &#125;) &#125; else if (robotData.code === 302000) &#123; commit('changeList', &#123; _id, message: '暂不支持此类对话' &#125;) &#125; else &#123; commit('changeList', &#123; _id, message: '暂不支持此类对话' &#125;) &#125; &#125;&#125;export default actions 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// vuex中state的数据只能被mutations方法所更改// mutations.jsconst mutations = &#123; // 对话 showDialog: (state) =&gt; &#123; // 判断当前动作是否是在打开对话，如果是在打开对话，那么进行判断当前当前进行对话的好友是否存在消息队列 // 如果当前活跃的好友不存在消息队列（被删除的）那么就恢复此好友的消息队列，如果存在，那么无动作 if (!state.dialog) &#123; // 空数组用来判断也是true，所以后面加个[0] let message = state.messageList.filter(x =&gt; x._id === state.activeId)[0] if (!message) &#123; let oldMessage = state.messageListFB.filter(x =&gt; x._id === state.activeId)[0] state.messageList.splice(oldMessage._id - 1, 0, oldMessage) &#125; &#125; state.dialog = !state.dialog &#125;, // 侧边栏 showSidebar: (state, &#123; flag &#125; = &#123;&#125;) =&gt; &#123; state.sidebar.open = !state.sidebar.open state.sidebar.docked = !flag &#125;, // 个人主页 showPersonindex: (state) =&gt; &#123; state.personindex = !state.personindex &#125;, // 搜索 showSearch: (state) =&gt; &#123; state.search = !state.search &#125;, // ajax获取到用户数据 getData: (state, data) =&gt; &#123; // 将ajax获取到的值赋予state state.data = data // ajax状态更改为结束 state.isAjax = true &#125;, // 标题 changTitle: (state, &#123; title &#125;) =&gt; &#123; state.headerTitle = title &#125;, // 获取当前获得关注的朋友的_id getActiveId: (state, &#123; activeId &#125;) =&gt; &#123; state.activeId = activeId &#125;, // 消息队列，聊天队列处理 changeList: (state, obj) =&gt; &#123; let now = new Date() let time = `$&#123;now.getHours()&#125;:$&#123;now.getMinutes()&#125;` // 判断信息是自己的还是ai的，然后插入聊天队列中 if (obj.self) &#123; // 信息是自己发送的 state.messageList.forEach((item, index, arr) =&gt; &#123; if (item._id === obj._id) &#123; obj._id = 0 item.list.push(&#123; ...obj, time &#125;) &#125; &#125;) &#125; else &#123; // 信息是ai发送的 state.messageList.forEach((item, index, arr) =&gt; &#123; if (item._id === obj._id) &#123; item.list.push(&#123; ...obj, time &#125;) &#125; &#125;) &#125; &#125;, // 删除消息 removeMessage(state, &#123; _id &#125;) &#123; state.messageList.forEach((item, index, arr) =&gt; &#123; // 判断信息列表中id与正在删除的信息id是否相同，如果相同，就删除信息 if (item._id === _id) &#123; arr.splice(index, 1) &#125; &#125;) &#125;&#125;export default mutations 123456789101112131415161718192021// getter.js// 类似计算数据，根据state的数据，筛选或者暴露一格新数据const getters = &#123; // 根据当前选中的朋友的_id来筛选出当前的friend的具体数据 friend: (state) =&gt; &#123; return state.data.friends.filter(x =&gt; x._id === state.activeId)[0] &#125;, // 对当前消息队列中的消息进行加工，添加对应的好友资料 nowMessageList: (state) =&gt; &#123; let list = state.messageList list.forEach(x =&gt; &#123; // 由_id筛选出对应的好友 let friend = state.data.friends.filter(i =&gt; i._id === x._id)[0] x.friend = friend &#125;) return list &#125;&#125;export default getters]]></content>
      <categories>
        <category>vue</category>
        <category>状态管理Vuex</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>状态管理Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装一个倒计时插件]]></title>
    <url>%2F2018%2F07%2F04%2FcountTime%2F</url>
    <content type="text"><![CDATA[倒计时设定时长 这种主要是通过设置时间长度进行倒计时 分析流程 countTime(options){} 首先封装的功能模块所传的参数主要有时间长度，设定以 s（秒） m（分） h（时） d（天）等关键字为一个参数，默认为 s（秒）; 接下来我们需要确认的是该功能模块设置倒计时该如何显示到页面中？这里我的想法是将显示倒计时设置到每个指定的元素中，这些元素通过一个数组参数进行设置[s,m,h,d]; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107function CountTime(options)&#123; if(new Date(options.endTime.replace(/-/g, "/")).getTime() &lt; Date.now())&#123; // alert("截止时间早于当前时间，请重新设置！"); return ; &#125; this.timeNum = options.TimeNum || 0; this.ElementArray = options.ElementArray; this.timesObj; this.TimeStr = options.TimeStr || "s"; this.endTimeFlag = options.endTimeFlag || false; this.curTime; this.endTime; this.s = 0; this.m = 0; this.h = 0; this.d = 0; this.init = function()&#123; this.curTime = new Date().getTime(); if(!this.endTimeFlag)&#123; if(this.TimeStr === "s")&#123; this.endTime = this.curTime*1 + (this.timeNum * 1000); this.setTime(this.endTime-this.curTime*1); &#125;else if(this.TimeStr === "m")&#123; this.endTime = this.curTime*1 + (this.timeNum * 1000 * 60); this.setTime(this.endTime-this.curTime*1); &#125;else if(this.TimeStr === "h")&#123; this.endTime = this.curTime + (this.timeNum * 1000 * 60 * 60); this.setTime(this.endTime-this.curTime*1); &#125;else if(this.TimeStr === "d")&#123; this.endTime = this.curTime*1 + (this.timeNum * 1000 * 60 * 60 * 24); this.setTime(this.endTime-this.curTime*1); &#125; &#125;else&#123; if(options.endTime)&#123; this.endTime = new Date(options.endTime.replace(/-/g, "/")).getTime();//此处做了移动端 ios Date对象的兼容处理。 &#125;else&#123; console.log("请设置 ‘endTime’ 项，否则请将 'endTimeFlag' 设置为false或不写，不写默认为false") &#125; &#125; this.interval(); return this; &#125;; this.setTime = function(times)&#123; this.d = Math.floor(times/1000/60/60/24) &gt; 0 ? Math.floor(times/1000/60/60/24) : 0; if(Math.floor(times/1000/60/60) &gt; 0)&#123; this.h = Math.floor(times/1000/60/60%24) &lt; 10 ? "0"+Math.floor(times/1000/60/60%24): Math.floor(times/1000/60/60%24); &#125;else &#123; this.h = "00"; &#125; if(Math.floor(times/1000/60) &gt; 0)&#123; this.m = Math.floor(times/1000/60%60) &lt; 10 ? "0"+Math.floor(times/1000/60%60): Math.floor(times/1000/60%60); &#125;else &#123; this.m = "00"; &#125; if(Math.floor(times/1000) &gt; 0)&#123; this.s = Math.floor(times/1000%60) &lt; 10 ? "0"+Math.floor(times/1000%60): Math.floor(times/1000%60); &#125;else &#123; this.s = 0; &#125; &#125;; this.setElement = function()&#123; let that = this; if(that.ElementArray.length === 1)&#123; $(that.ElementArray[0]).html(this.d) &#125;else if(that.ElementArray.length === 2)&#123; $(that.ElementArray[0]).html(this.d); $(that.ElementArray[1]).html(this.h); &#125;else if(that.ElementArray.length === 3)&#123; $(that.ElementArray[0]).html(this.d); $(that.ElementArray[1]).html(this.h); $(that.ElementArray[2]).html(this.m); &#125;else if(that.ElementArray.length === 4)&#123; $(that.ElementArray[0]).html(this.d); $(that.ElementArray[1]).html(this.h); $(that.ElementArray[2]).html(this.m); $(that.ElementArray[3]).html(this.s); &#125; &#125;; this.interval = function()&#123; let that = this; let timer = setInterval(function()&#123; that.curTime = new Date().getTime(); if(that.s &lt; 0)&#123; clearInterval(timer) &#125;else&#123; that.setTime(that.endTime-that.curTime); that.setElement(); that.timesObj =&#123; days:that.d, hours:that.hours, minutes:that.m, second: that.s &#125; &#125; &#125;,1000) &#125;&#125;/*使用方法:let timers = new CountTime(&#123; TimeNum: 5, ElementArray:[".day",".hour",".min",".sec"], TimeStr:"h"&#125;).init();*/]]></content>
      <categories>
        <category>JS封装</category>
      </categories>
      <tags>
        <tag>倒计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 从零开始了解微信小程序的开发（二）]]></title>
    <url>%2F2018%2F06%2F30%2FWeChatSmallProgram1%2F</url>
    <content type="text"><![CDATA[这个项目周期可能会很久，毕竟我只是一个前端，后台那部分还需要边学边开发。 项目需求 项目需求：首先开发这个项目 目的是什么？ 项目UI项目配置使用iconfont字体图标123456789/* app.wxss */ @font-face &#123; font-family: 'iconfont'; /* project id 431644 */ src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot'); src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.woff') format('woff'), url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.ttf') format('truetype'), url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.svg#iconfont') format('svg'); &#125; 12345678/*初始化样式*/.icon&#123; display: inline-block; font-family: 'iconfont';&#125;.icon-home::before&#123; content: "\e600";&#125; 1&lt;view class="icon icon-home"&gt;&lt;/view&gt; 项目开发前端后台在自己的服务器上部署小程序后台环境 node/php（wamp）+ mysql数据库 node环境的搭建 说起node环境的搭建真是一步一个坑的踩过来，所以赶紧写下来备忘。 首先在腾讯云上搞个服务器，（域名备案，并且生成ssl证书下载）； 随后需要在服务器上安装node环境 ，由于小白，所以选择服务器的系统时用的是window server2012版本。 安装好node之后安装Nginx反向代理，这里是最坑的，配置这个反向代理的坑点如下 1.下载nginx1.8.1版本,解压后上传到服务器。 2.这里配置nginx.conf这个文件时 千万不要用! 千万不要用! 千万不要用! （重要的事情说三遍！）记事本打开！最好使用IDE编辑器打开文件。 3.配置文件内容如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; upstream app_weapp &#123; server 172.17.0.9:443; keepalive 8; &#125; upstream app_wxapp &#123; server 182.254.140.217:443; keepalive 8; &#125; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; server &#123; listen 443; server_name www.mrsxin.cn; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # # server &#123; # listen 443 ssl; # server_name www.mrsxin.cn; # 此处的文件可以通过腾讯云申请免费的安全SSL证书。申请成功后下载解压将nginx下的文件拷贝至nginx安装目录下 # ssl_certificate /wamp64/www/nginx-1.8.1/html/1_www.mrsxin.cn_bundle.crt; # ssl_certificate_key /wamp64/www/nginx-1.8.1/html/2_www.mrsxin.cn.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; # &#125; server &#123; listen 443 ssl; server_name www.mrsxin.cn; # ssl on; ssl_certificate /wamp64/www/nginx-1.8.1/html/server/bin/1_www.mrsxin.cn_bundle.crt; # 此处的文件可以通过腾讯云申请免费的安全SSL证书。申请成功后下载解压将nginx下的文件拷贝至nginx安装目录下 ssl_certificate_key /wamp64/www/nginx-1.8.1/html/server/bin/2_www.mrsxin.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA; ssl_session_cache shared:SSL:50m; ssl_prefer_server_ciphers on; location / &#123; proxy_pass https://localhost:520/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &apos;upgrade&apos;; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; # root /wamp64/www/nginx-1.8.1/html # index server.js &#125; &#125;&#125; 4.配置好此文件后 在nginx安装文件夹下使用命令行nginx -s reload命令 mysql的安装 转自：正确解法 💎 点此查看 Npm提供了mysql数据库驱动模块的，通过npm install –save-dev mysql将mysql模块安装到本项目，注意npm中mysql模块只支持mysql 5.7+版本的数据库，接下来就是安装从mysql官网安装mysql数据库软件了； 将下载的mysql压缩包文件解压并放置电脑的任何目录中，我的解压目录D:\ mysql-5.7.18 添加环境变量：右键单击计算机&gt;属性&gt;高级系统设置&gt;环境变量；在系统变量添加MYSQL_HOME，并mysql路径设置为变量值； 同时在系统变量里找到path，选择编辑，在原有值末尾添加数据库的安装目录中的bin文件夹路径。%MYSQL_HOME%\bin 添加配置文件： 在MySQL的安装目录（例如D: \mysql-5.7.18）中，新建my.ini文件（注意扩展名是ini），并用记事本打开进行编辑。 初始化数据库： 以管理员自身份打开CMD执行以下命令（注意必须以管理员身份打开，否则报错） mysqld –initialize –user=mysql –console 在控制台消息尾部会出现随机生成的初始密码，将打印出来的初始密码保存起来，不要忘记 如果上述命令运行不成功请用以下命令代替： %MYSQL_HOME%\bin\mysqld –initialize –user=mysql –console 如果仍然不成功请检查第２步 将MySQL添加到系统服务，以管理员自身份打开CMD执行以下命令（注意必须以管理员身份打开，否则报错） mysqld –install MySQL net start MySQL 安装成功，则显示“服务已启动成功” 如果上述命令运行不成功，可以用以下命令代替： %MYSQL_HOME%\bin\mysqld –install MySQL net start MySQL 安装成功，则显示“服务已启动成功” 如果仍然不成功请检查第２步 启动MySQL并修改密码，在CMD控制台里执行命令 mysql -u root -p 回车执行后，输入刚才记录的随机密码 执行成功后，控制台显示 mysql&gt;，则表示进入mysql 输入命令set password for root@localhost =password(‘123’);（注意分号） 输入命令select version();（注意分号）查看版本号 输入命令show global variables like “port”;（注意分号）查看端口 输入命令status;（注意分号）查看mysql基本状态信息 使用node+hapi+https 通常不直接在应用程序上处理https请求，但是Hapi。js可以在相同的API中处理http和https。12345678910111213141516171819202122232425//var Hapi = require('hapi');var server = new Hapi.Server();var fs = require('fs');var tls = &#123; key: fs.readFileSync('/etc/letsencrypt/live/example.com/privkey.pem'), cert: fs.readFileSync('/etc/letsencrypt/live/example.com/cert.pem')&#125;;server.connection(&#123;address: '0.0.0.0', port: 443, tls: tls &#125;);server.connection(&#123;address: '0.0.0.0', port: 80 &#125;);server.route(&#123; method: 'GET', path: '/', handler: function (request, reply) &#123; reply('Hello, world!'); &#125;&#125;);server.start(function () &#123; console.log('Server running');&#125;); 也可以将所有http请求重定向到https:12345if (request.headers['x-forwarded-proto'] === 'http') &#123; return reply() .redirect('https://' + request.headers.host + request.url.path) .code(301);&#125; 项目提交项目总结]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>实战项目</tag>
        <tag>展示类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DailyCase-devicemotion]]></title>
    <url>%2F2018%2F06%2F22%2FDailyCase-devicemotion%2F</url>
    <content type="text"><![CDATA[重力感应事件相关文档### 应用小案例]]></content>
      <categories>
        <category>每日一更demo</category>
      </categories>
      <tags>
        <tag>H5之重力感应事件</tag>
        <tag>前端案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typed.js 一个实现打字机效果的库]]></title>
    <url>%2F2018%2F06%2F19%2FTyped-js%2F</url>
    <content type="text"><![CDATA[Typed.js 使用Typed.js 库的安装安装NPM:1npm install typed.js Yarn1yarn add typed.js Bower1bower install typed.js Setup1234567// Can also be included with a regular script tagimport Typed from &apos;typed.js&apos;;var options = &#123; strings: [&quot;&lt;i&gt;First&lt;/i&gt; sentence.&quot;, &quot;&amp;amp; a second sentence.&quot;], typeSpeed: 40&#125;var typed = new Typed(&quot;.element&quot;, options); 实例化HTML12345&lt;div id="typed-strings"&gt; &lt;p&gt;Typed.js is a &lt;strong&gt;JavaScript&lt;/strong&gt; library.&lt;/p&gt; &lt;p&gt;It &lt;em&gt;types&lt;/em&gt; out sentences.&lt;/p&gt;&lt;/div&gt;&lt;span id="typed"&gt;&lt;/span&gt; javascript12345&lt;script&gt; var typed = new Typed(&apos;#typed&apos;, &#123; stringsElement: &apos;#typed-strings&apos; &#125;);&lt;/script&gt; 配置12345678910111213141516&#123;//数组类型,里面存放文本内容，输出的文本。从下标0开始，打印第一个，从新覆盖，打印出第二个。注意：输出标签时，在input会直接输出标签，如果在一个div内，会当标签执行掉 strings: [&quot;These are the default values...&quot;, &quot;You know what you should do?&quot;, &quot;Use your own!&quot;, &quot;Have a great day!&quot;], backSpeed: 60, //删除字的速度 startDelay: 100, //每一句开始打字停顿的时间 backDelay: 500, //每一句删除字的停顿时间 loop: true, //是否循环动画 loopCount: 5/Infinity, //循环次数 showCursor: true, //是否显示光标 cursorChar: &quot;︳&quot;, //设置光标字符 autoInsertCss: false, fadeOut boolean, //类型，开启运动效果，==和下面的fadeOutClass和fadeOutDelay才能看出效果== fadeOutClass:’typed-fade-out’, //string 类型，比如：’typed-fade-out’值 fadeOutDelay: 500, //number 类型，设置淡出为毫秒为单位。&#125; 对这个库的分析理解 起初看到这个插件库的时候我以为可以控制每段文字是否可以回删，后来仔细的了解之后，额是我想多了，那种每段文字有时间间隔 有换行的那种效果其实是某一个元素中的处理。 例如：12strings : [&quot;事业和爱情.^2000\n我爱写程序.^2000\n我爱做很Cool的东西.^2000\n谢谢...&quot;],//这里的 ^2000 是指定的间隔时间 \n 换行 案例开发 现在我想做一个输出一段代码，并且这段代码的样式像编辑器里的代码样式那样，有各式各样的样式区分，这里首先想到的一个难点是，在这个插件解析输入的文本时除了input标签里会把标签当做字符串输出来，其他的标签则会解析对应的标签，这个问题该如何解决？ 案例的需求分析 既然有了这样的需求，那么就想办法解决一下完成这个需求中的难点 难点解决 这个难点的问题在于标签在除 input 标签里都会发生标签的解析，这样我们在输出的文本中就无法完成标签的显示，其实在配置项中有个配置叫做 contentType 默认设置为 html,当我们不需要解析标签时将其设置为 ‘null’ 就ok了,但是这样又存在一个问题，这样做的结果是所有的标签都不会解析了，如果说我们需要设置样式的话就没办法完成了。很痛苦啊。12关键的一点就是这个了strings : [`&lt;span style=&apos;color: #8ba7c9;&apos;&gt;&lt;&lt;span style=&apos;color: #dd6655&apos;&gt;span&lt;/span&gt;&gt;&lt;span style=&quot;color:#fff&quot;&gt;这是输出的span标签里的内容&lt;/span&gt;&lt; /&lt;span style=&apos;color: #dd6655&apos;&gt;span&lt;/span&gt;&gt;&lt;/span&gt;^2000`],]]></content>
      <categories>
        <category>实现一个打字机效果小案例</category>
      </categories>
      <tags>
        <tag>前端库</tag>
        <tag>Typed.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[compatibility 工作中遇到的一些问题]]></title>
    <url>%2F2018%2F06%2F15%2Fcompatibility%2F</url>
    <content type="text"><![CDATA[兼容IOS new Date() 在ios中不识别 2018-06-14 中的‘-’，只识别‘/’，当时做项目的时候在模拟机上测试没有问题，安卓也没有问题，但是一上ios真机就bug了，很难受，最后还是alert() 出 new Date(2018-06-14 23:00:00) 的时候为 invalid date,这才发现问题。 let 关键字 不兼容9.3以下版本 ios中，输入框获得焦点时，页面输入框被遮盖，定位的元素位置错乱：当页input存在于吸顶或者吸底元素中时，用户点击输入框，输入法弹出后，fiexd失效，页面中定位好的元素随屏幕滚动。 针对这个问题，我们一起来看下以下几种方案： 方案一： Web API 接口 ：scrollIntoView 的应用，将input输入框显示在可视区域。 123456789101112// 输入框获得焦点时，元素移动到可视区域 inputOnFocus(e)&#123; setTimeout(function()&#123; e.target.scrollIntoView(true); // true:元素的顶端将和其所在滚动区的可视区域的顶端对齐; false:底端对齐。 &#125;,200); // 延时 == 键盘弹起需要时间 &#125; inputOnbulr(e)&#123; e.target.parentNode.className ='input input-fixed'; clearInterval(timer) &#125; 输入框获得焦点可弹出软键盘，却没有光标闪烁，也无法正常输入。 原因：-webkit-user-select:none 导致的，可以这样解决:1234*:not(input,textarea)&#123; -webkit-touch-callout: none; -webkit-user-select: none; &#125; input 自定义样式1234input::-webkit-input-placeholder,input::-moz-placeholder,input::-ms-input-placeholder&#123;...styletext-align: center;&#125; 安卓工作中遇到的一些问题样式contenteditable属性 将块元素变成可输入状态 contenteditable=true css处理文字超出部分显示省略号1.单行12345span&#123; overflow: hidden; text-overflow:ellipsis; white-space: nowrap;&#125; 2.多行123456span&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;&#125; 注意： 在vue等js框架中编译打包后浏览器不识别，可能是由于文件中的注释耦合。 解决办法就是将样式直接写在行内样式里，这样的话会避免这种BUG。 css写个小三角1234567891011121314151617181920212223242526272829303132333435/*最高性能等边三角图形绘制*/ div &#123; width: 0; border: 10px solid; border-color: #f30 transparent transparent; &#125;/*最高性能等腰三角图形绘制*/ div &#123; width: 0; border-width: 20px 10px; border-style: solid; border-color: #f30 transparent transparent; &#125;/*对话框气泡下的三角形*/ div &#123; width: 0; border-width: 20px 10px; border-style: solid; border-color: #f30 #f30 transparent transparent; &#125;/*最高性能梯形图形绘制*/ div &#123; width: 10px; height: 10px; border: 10px solid; border-color: #f30 transparent transparent; &#125; 逻辑js摇一摇代码1234567891011121314151617181920212223if (window.DeviceMotionEvent) &#123; window.addEventListener('devicemotion',deviceMotionHandler, false); &#125; var speed = 38;//speed var x = y = z = lastX = lastY = lastZ = 0; function deviceMotionHandler(eventData) &#123; var acceleration =eventData.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX) &gt; speed || Math.abs(y-lastY) &gt; speed || Math.abs(z-lastZ) &gt; speed) &#123; //简单的摇一摇触发代码 num++;//摇一摇次数 if(num&gt;100)&#123; window.removeEventListener('devicemotion',deviceMotionHandler, false); &#125; $('.num').text(num); &#125; lastX = x; lastY = y; lastZ = z; &#125; 手指缩放逻辑123456//touchmove xMove = e.touches[1].clientX - e.touches[0].clientX; yMove = e.touches[1].clientY - e.touches[0].clientY; distance = Math.sqrt(xMove * xMove + yMove * yMove); //图片缩放比例 0.005是一个用户体验比较好的缩放系数 newScale = oldScale + 0.005 * distanceDiff 数组统计数组中相同项的个数 很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用reduce方法处理这个数组。 123456var cars = ['BMW','Benz', 'Benz', 'Tesla', 'BMW', 'Toyota'];var carsObj = cars.reduce(function (obj, name) &#123; obj[name] = obj[name] ? ++obj[name] : 1; return obj;&#125;, &#123;&#125;);carsObj; // =&gt; &#123; BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 &#125; Set实现数组去重 在ES6中，因为Set只存储唯一值，所以你可以使用Set删除重复项。 12let arr = [1, 1, 2, 2, 3, 3];let deduped = [...new Set(arr)] // [1, 2, 3] 对Set使用数组方法 使用扩展运算符就可以简单的将Set转换为数组。所以你可以对Set使用Array的所有原生方法。 12let mySet = new Set([1,2, 3, 4, 5]);var filtered = [...mySet].filter((x) =&gt; x &gt; 3) // [4, 5] 对象使用解构删除不必要属性 有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。 123let &#123;_internal, tooBig, ...cleanObject&#125; = &#123;el1: '1', _internal:"secret", tooBig:&#123;&#125;, el2: '2', el3: '3'&#125;;console.log(cleanObject); // &#123;el1: '1', el2: '2', el3: '3'&#125; 合并对象 ES6带来了扩展运算符（…）。它一般被用来解构数组，但你也可以用它处理对象。 1234let object1 = &#123; a:1, b:2,c:3 &#125;let object2 = &#123; b:30, c:40, d:50&#125;let merged = &#123;...object1, ...object2&#125; //spread and re-add into mergedconsole.log(merged) // &#123;a:1, b:30, c:40, d:50&#125; 密封的对象 密封对象不可扩展，且不能删除属性和方法 12345678let person = &#123; name: 'addone' &#125;;Object.seal(person);person.age = 20;delete person.name;person.age // undefinedperson.name // addone 相对的也有Object.isSealed()来判断是否密封 冻结的对象 这是最严格的防篡改级别，冻结的对象即不可扩展，又密封，且不能修改 123456789let person = &#123; name: 'addone' &#125;;Object.freeze(person);person.age = 20;delete person.name;person.name = 'addtwo'person.age // undefinedperson.name // addone **同样也有` Object.isFrozen `来检测** JS小数计算不准确的bug1234567console.log(0.1 + 0.2);console.log(0.1 + 0.2 == 0.3);//答案: 0.30000000000000004 false//解决办法parseFloat((0.1+0.2).toFixed(10)); 经典面试题1.考察变量的提升 undefined 为 window 对象的属性12345678var y = 10;if(!(x in window))&#123; var x=10;&#125;else&#123; ++y;&#125; console.log(x);// undefinedconsole.log(y);// 11 跨域 跨域作为一个老生常谈的问题，在这里就说明 三个关键点 协议、域名 、端口 这三点的不同决定着是否跨域。 先谈谈跨域的几种解决方式 jsonp 这是最简单暴力的方式，但是这种方式最不安全，最容易被注入攻击。项目中有个需求 在某信某个活动中，需要请求大量数据，并且并发量会很高，后台把一部分接口写在了另一个服务器中，数据也放在了另一个服务器里，这样前端就涉及到了跨域请求数据了。 VUEvue中的 keep-alive keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 注意：当组件在 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 关于 Vue2.0 路由开启 keep-alive 时需要注意的地方 首次进来 hook 的触发顺序 created-&gt; mounted-&gt; activated，退出时触发 deactivated： 二次进来 hook 只触发 activated，退出时触发 deactivated： 注意：在开启keep-alive时最好把请求数据写在 activated 生命周期中，这样在首次加载页面的时候不会请求多次数据，优化一点性能. 1234567891011121314151617&lt;!-- 基本 --&gt;&lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt; &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; include 和 exclude 1234567891011121314&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 这里可以使用路由中的路由元信息 meta 来设置是否使用比如 可以在配置某个路由时设置 123456789101112const routes= [&#123; path: '/article', name: 'article', meta: &#123; login: true, keepAlive:true,//在需要使用keep缓存的路由组件中配置该项，然后在 APP.vue 中使用$route.meta.keepAlive 做是否加载keepAlive &#125;, components: &#123; container: Article, footer: Mainfooter &#125;&#125;]; vue 进入/离开 &amp; 列表过渡概述Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：在 CSS 过渡和动画中自动应用 class可以配合使用第三方 CSS 动画库，如 Animate.css在过渡钩子函数中使用 JavaScript 直接操作 DOM可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡 12345678&lt;div id="demo"&gt; &lt;button v-on:click="show = !show"&gt; Toggle &lt;/button&gt; &lt;transition name="fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) 123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; CSS 过渡 常用的过渡都是使用 CSS 过渡。 12345678&lt;div id="example-1"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;transition name="slide-fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-1', data: &#123; show: true &#125;&#125;) 12345678910111213/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active for below version 2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125; CSS 动画 CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。 123456&lt;div id="example-2"&gt; &lt;button @click="show = !show"&gt;Toggle show&lt;/button&gt; &lt;transition name="bounce"&gt; &lt;p v-if="show"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-2', data: &#123; show: true &#125;&#125;) 1234567891011121314151617.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 自定义过渡的类名 我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。 1234567891011121314&lt;link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css"&gt;&lt;div id="example-3"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;transition name="custom-classes-transition" enter-active-class="animated tada" leave-active-class="animated bounceOutRight" &gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-3', data: &#123; show: true &#125;&#125;) 显性的过渡持续时间 123&lt;transition :duration="1000"&gt;...&lt;/transition&gt;&lt;!--定制一套属于自己的 过渡时间--&gt;&lt;transition :duration="&#123; enter: 500, leave: 800 &#125;"&gt;...&lt;/transition&gt; JavaScript 钩子 12345678910111213&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748new Vue(&#123; el: '#example-3', data: &#123; show: true &#125;, methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125; &#125;&#125;) 注意： 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。 vue 中通过webpack全局引入jQuery 通过npm安装jQuery组件：npm i jquery --save 在 build/webpack.base.conf.js 里加入: const webpack = require(&quot;webpack&quot;)123456789101112131415161718192021222324module.exports = &#123; // 其他代码... resolve: &#123; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;], fallback: [path.join(__dirname, &apos;../node_modules&apos;)], alias: &#123; &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;), &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;), &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;), // webpack 使用 jQuery，如果是自行下载的 // &apos;jquery&apos;: path.resolve(__dirname, &apos;../src/assets/libs/jquery/jquery.min&apos;), // 如果使用NPM安装的jQuery &apos;jquery&apos;: &apos;jquery&apos; &#125; &#125;, // 增加一个plugins plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; &#125;) ], // 其他代码...&#125;; 重新运行 npm run dev vue- 样式问题vue- scoped 在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于当前的Vue组件，可以使组件的样式不相互污染。如果一个项目的所有style标签都加上了scoped属性，相当于实现了样式的模块化。 scoped 实现原理：Vue中的scoped属性的效果主要是通过PostCss实现的。PostCss给组件中的所有dom元素添加了一个独一无二的动态属性值，给所有的css选择器添加了一个对应的属性选择器，进而选择对应组件中的dom元素，所以对应的样式作用于对应的组件。 vue- scoped穿透 scoped穿透主要是解决在项目中用到第三方组件库的时候，需要在局部组件中修改第三方组件的样式，又不想去掉scoped属性造成组件之间的样式覆盖污染。 解决方法 在 stylus 中的样式穿透： &gt;&gt;&gt; 1234.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background: #fff``` - 在 sass 和 less 的样式穿透 使用 `/deep/` .wrapper /deep/ .swiper-pagination-bullet-active{ background: #fff; }1234567891011121314151617181920212223##### vue组件的递归&gt; 首先来说说什么是递归组件，简单来说就是在组件内部使用自身组件，和函数的递归一样样的。一般这样的递归组件会用在哪里呢？肯定是在组件渲染数据的时候数据结构是一层嵌套一层，例如tree状数据结构。```vue &lt;template&gt; &lt;div&gt; &lt;div class=&quot;list-item&quot; v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt; &lt;div class=&quot;item-name&quot;&gt; &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div v-if=&quot;item.children&quot; class=&quot;children-item&quot;&gt; &lt;list :list=&quot;item.children&quot;&gt;&lt;/list&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: &quot;List&quot;, props: &#123; list: Array &#125; &#125;; &lt;/script&gt; 这里的 props 中的 list 作为父组件传递给子组件的数据，通过 props 属性接收。仔细看也会注意到嵌套第二层的数据时会有个 v-if 的判断，当子层数据存在时，会再次渲染递归组件，这样就会形成无论数据嵌套多少层，我们只需要写一次代码。 并且在组件内部调用组件时不需要引用，直接调用起，这样更加方便。 vue cli 3.0 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 module.exports = &#123; baseUrl: process.env.NODE_ENV === 'production' ? './' : '/', assetsDir: 'static', // pages, devServer: &#123; host: '192.168.1.182', // 设置默认端口 port: 8080, // 设置代理 proxy: &#123; '/api': &#123; // 目标 API 地址 target: 'https://vote.51takeit.com', // target: 'https://js.51takeit.com', // 将主机标头的原点更改为目标URL changeOrigin: true, pathRewrite: &#123; '^/api': 'https://vote.51takeit.com/api' // '^/api': 'https://js.51takeit.com/api' &#125; &#125; &#125; &#125;, lintOnSave: false, // 输出文件目录 outputDir: 'dist', // webpack配置 // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md chainWebpack: () =&gt; &#123;&#125;, configureWebpack: () =&gt; &#123;&#125;, // 生产环境是否生成 sourceMap 文件 productionSourceMap: false, // css相关配置 css: &#123; // 是否使用css分离插件 ExtractTextPlugin extract: true, // 开启 CSS source maps? sourceMap: false, // css预设器配置项 loaderOptions: &#123;&#125;, // 启用 CSS modules for all css / pre-processor files. modules: false &#125;, /* 构建多页面模式的应用程序.每个“页面”都应该有一个相应的JavaScript条目文件。该值应该是一 个对象，其中键是条目的名称，而该值要么是指定其条目、模板和文件名的对象，要么是指定其条目 的字符串， 注意：请保证pages里配置的路径和文件名 在你的文档目录都存在 否则启动服务会报错的 */ pages: &#123; index: &#123; entry: 'src/main.js', template: 'public/index.html', filename: 'index.html' &#125;, sub: &#123; entry: 'src/main.js', template: 'public/sub.html', filename: 'sub.html' &#125; &#125;&#125; 其他npm 操作时出现过的报错 -4048 有可能是权限问题，也有可能是npm 缓存问题 ，解决这个问题可以先清除缓存试试 npm cache clean --force 清理本地缓存]]></content>
      <categories>
        <category>前端兼容问题</category>
        <category>css样式处理</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>ios兼容</tag>
        <tag>安卓兼容</tag>
        <tag>vue 组件过渡效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FrontEndResources 资源积累]]></title>
    <url>%2F2018%2F06%2F12%2FFrontEndResources%2F</url>
    <content type="text"><![CDATA[一组资源分享开发类前端库 实现打字机的效果 💎 Three.js-3D-手册 💎工具1.图片压缩网站 💎2.平面设计网站 💎3.8000个分类好的icon 💎框架构建部署后端设计类色彩 非常好用的渐变色网站 WebGradients.com 💎 ColorDrop - New colors 免费的图片资源网站-PEXELS规范其他类]]></content>
      <categories>
        <category>资源积累</category>
      </categories>
      <tags>
        <tag>色彩搭配</tag>
        <tag>开发库资源</tag>
        <tag>开发组件资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉一个节约开发时间的库和资源]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%8B%89%E4%B8%80%E4%B8%AA%E8%8A%82%E7%BA%A6%E5%BC%80%E5%8F%91%E6%97%B6%E9%97%B4%E7%9A%84%E5%BA%93%E5%92%8C%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[JavaScript 库Particles.js 在网页上创建炫酷的漂浮例子的库，在网站首页比较常见。 Three.js 在网页上创建 3D 对象和空间的库，常用于网页游戏。 Fullpage.js 轻松创建全屏滚动的网页。 Typed.js 实现打字机的效果。 Waypoints.js 实现滚动一个元素触发一个函数的最简单的方式。 Highlight.js 自动检测语言及高亮语法。 Chart.js 纯 JavaScript 实现炫酷图表。 Instantclick 大大提升网页加载效率，在鼠标悬停时预加载资源。 Chartist 另一个图表库。 Motio 实现基于 sprite 的动画和平移效果的库。 Animstion css 动画页面切换效果的 JQuery 插件 Barba.js 流畅和平滑的页面过渡效果。 TwentyTwenty 一个视觉差异工具，突出两个图像之间的差异。 Vivus.js 用于在 SVG 上绘制动画的库。 Wow.js 滚动时显示动画。 Scrolline.js 显示页面的滚动进度条。 Velocity.js 快速、平滑的 JavaScript 动画。 Animate on scroll 另一个滚动显示动画的库。 Handlebars.js —— JavaScript 模版。 jInvertScroll —— 轻量级的水平视差插件。 One page scroll —— 与 FullPage 类似。 Parallax.js —— 视觉引擎，对智能设备的方向做出反应。 Typeahead.js —— 自动匹配搜索。 Dragdealer.js —— 相当酷的实现拖动效果的库。 Bounce.js —— 创建炫酷的 CSS3 动画。 Pagepiling.js —— 又一个 one page scroll. Multiscroll.js —— 实现多列滚动面板效果。 Favico.js —— 动态图标。 Midnight.js —— 无缝切换固定标题。 Anime.js —— 动画库。 Keycode —— 获得按键的 JavaScript 键码。 Sortable —— 拖动排序控件。 Flexdatalist —— 输入补全。 Slideout.js —— 在网页上实现抽屉效果的侧边导航栏。 Jquerymy —— 使用 jquery 的两种数据绑定方式。 Cleave.js —— 格式化输入内容。 Page —— 小型客户端路由库。 Selectize.js —— 用于添加标签的选择框。 Nice select —— 用于创建奈斯型选择框。 Tether —— 可以有效地固定绝对定位的元素。 Shepherd.js —— 实现指导用户使用应用的效果。 Tooltip —— 提示信息。 Select2 —— 丰富的自定义选择框。 IziToast —— 容易实现的 JS 通知。 IziModal —— 容易实现的 JS 弹窗。 CSS 库／设计类Animate.css —— 动画库。 Flat UI Colors —— 简单有效的颜色。 Material design lite —— 基于 Google 的 Material Design。 Materialui.co —— 许多 Material Design 框架的资源。 Colorrrs —— 随机颜色生成器。 Section separators —— CSS 分割线。 Topcoat —— 简单快速的 CSS 框架。 Create ken burns effect —— 使用 CSS 动画的 Ken Burns 效果。 DynCSS —— 为 CSS 添加函数，让它变成动态的。 Magic animations —— 人如其名。 CSSpin —— CSS 旋转控件集合。 Feather icons —— 图标。 Ion icons —— 图标。 Font awesome —— 图标。 Font generator —— 组合多种字体，生成一个混合体。 On/Off switch —— 开关按钮。 UI Kit —— 轻型的模块化框架。 Bootstrap —— 这个就不谈了。 Foundation —— 号称最先进的响应式前端框架。]]></content>
      <categories>
        <category>节约开发时间成本的资源清单</category>
      </categories>
      <tags>
        <tag>js库</tag>
        <tag>css 库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD - 异步模块定义]]></title>
    <url>%2F2018%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[AMD 是”Asynchronous Module Definition”的缩写,意思就是”异步模块定义“.它采用异步方式加载模块,模块的加载不会影响它后面程序语句的运行.所有依赖这个模块的语句,都定义在一个回调函数中,等到加载完成之后这个回调函数才会运行. AMD如何加载模块 AMD 也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：1require([module], callback); 第一个参数[module],是一个数组，数组元素就是需要依赖的加载模块,第二个参数是一个回调函数,这个回调函数在第一个参数中的模块加载成功之后才会执行.例如123require([&apos;math&apos;],function(math)&#123; math.add(2,3);&#125;) 注意 此时math.add()与math模块加载不是同步的,浏览器不会发生请求数据时的假死状态. require.js 之前文件中一次加载很多js文件的写法有很大的缺点,加载的时候,浏览器会停止网页渲染,所以加载的文件越多,网页失去响应的时间就会越长,由于js文件之间存在依赖关系,因此在依赖关系复杂的时候代码的而编写就会变得很困难. require JS 的诞生主要解决了两个问题 实现js文件的异步加载,避免网页失去响应; 管理模块之间的依赖性,便于代码的编写和维护; require.js 的加载 两种引入方式： 1.在文件头部引入时需要异步加载并且如要兼容IE则需要加defer 1&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt; 2.在页面底部引入 引入require.js后就需要引入自己的js文件了 1&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; data-main 属性的作用是,指定网页程序的主模块.main.js会被require加载,由于require 默认的文件后缀是js,所以可以把main.js写成main1234567891011121314151617require.config(&#123; baseUrl: &quot;js/lib&quot;,//指定js加载的基目录 paths: &#123; &quot;jquery&quot;: &quot;jquery.min&quot;, &quot;underscore&quot;: &quot;underscore.min&quot;, &quot;backbone&quot;: &quot;backbone.min&quot; &#125;， shim:&#123;//这个属性是专门用来配置不兼容的模块1exports暴露出去的变量名称，deps数组表明该模块的依赖 &apos;jquery.scroll&apos;:&#123; deps:[&apos;jquery&apos;], exports:&apos;jQuery.fn.scroll&apos; &#125; &#125;&#125;);require([&apos;jquery&apos;,&apos;uderscore&apos;,&apos;backbone&apos;],function($,_,Backbone)&#123; &#125;)]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 从零开始了解微信小程序的开发（一）]]></title>
    <url>%2F2018%2F06%2F06%2FWeChatSmallProgram%2F</url>
    <content type="text"><![CDATA[摘要：记录这个一是帮助更多从零开始的开发小白可以通俗易懂的了解小程序开发，另外一个目的就是对小程序开发从零开始总结梳理一下，帮助别人的同时提升自己。（ps - 在总结中成长，不论是任何行业都适用的一句真言。） 微信小程序框架部分目录结构 pages index index.wxml index.wxss index.js logs app.js app.json app.wxss 配置 app.json pages 接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。 123456&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ]&#125; window 1234567891011&#123; &quot;window&quot;:&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;navigationStyle&quot;: &quot;custom&quot;, &quot;enablePullDownRefresh&quot;: false &#125;&#125; tabBar 如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 注意：当设置 position 为 top 时，将不会显示 icon，list是一个数组，该数组最少配置2个tab，最多5个tab，tab按照数组的顺序进行排列。 1234567891011121314151617&#123; &quot;tabBar&quot;:&#123; &quot;position&quot;:&quot;bottom&quot;, &quot;borderStyle&quot;:&quot;black&quot;, &quot;color&quot;:&quot;#FFF&quot;, &quot;selectedColor&quot;:&quot;#333&quot;, &quot;list&quot;:[ &#123; &quot;text&quot;:&quot;首页&quot;, &quot;pagePath&quot;:&quot;pages/index/index&quot;, &quot;iconPath&quot;:&quot;/static/images/index.png&quot;, &quot;selectedIconPath&quot;:&quot;/static/images/index.png&quot; &#125;, ], &quot;backgroundColor&quot;:&quot;#efefef&quot; &#125;&#125; networkTimeout 可以设置各种网络请求的超时时间。 12345678&#123; &quot;networkTimeout&quot;:&#123; &quot;request&quot;: 6000, &quot;connectSocket&quot;: 6000, &quot;uploadFile&quot;: 6000, &quot;downloadFile&quot;: 6000, &#125;&#125; page.json 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 12345678910&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;enablePullDownRefresh&quot;: false, &quot;disableScroll&quot;: false,//true 设置页面整体不能上下滚动，仅设置在page.json &quot;onReachBottomDistance&quot;: 50 &#125; 框架逻辑层注册程序 APP() 函数用来注册一个小程序。接收一个object参数。 1234567891011121314App(&#123; onlaunch()&#123; //监听一个小程序的初始化，全局只触发一次 `生命周期函数` &#125;， onShow()&#123; //监听一个小程序的页面显示的 `生命周期函数` &#125;, onHide()&#123; //监听一个小程序的页面隐藏的 `生命周期函数` &#125;, onPageNotFound()&#123; //监听一个小程序的页面不存在的 `生命周期函数` &#125;&#125;) 场景值|场景值|说明| |:-------:|:---:| |1001|发现栏小程序主入口| |1005|顶部搜索框的搜索结果页| |1006|发现栏小程序主入口搜索框的搜索结果页| |1007|单人聊天会话中的小程序消息卡片| |1008|群聊会话中的小程序消息卡片| |1011|扫描二维码| |1012|长按图片识别二维码| |1013|手机相册选取二维码| |1014|小程序模版消息| |1017|前往体验版的入口页| |1019|微信钱包| |1020|公众号 profile 页相关小程序列表| |1022|聊天顶部置顶小程序入口| |1023|安卓系统桌面图标| |1024|小程序 profile 页| |1025|扫描一维码| |1026|附近小程序列表| |1027|顶部搜索框搜索结果页“使用过的小程序”列表| |1028|我的卡包| |1031|长按图片识别一维码| |1032|手机相册选取一维码| |1036|App 分享消息卡片| |1044|带 shareTicket 的小程序消息卡片（详情)| |1047|扫描小程序码| |1089|微信聊天主界面下拉| |1090|长按小程序右上角菜单唤出最近使用历史| 注册页面 Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。 onShareAppMessage() : 用户转发 只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮 用户点击转发按钮的时候会调用 此事件需要 return 一个 Object，用于自定义转发内容 Object自定义转发字段 title 转发标题 默认当前小程序的名称path 转发路径 默认当前页面path，必须是以/开头的完整路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Page(&#123;//data 将会以 JSON 的形式由逻辑层传至渲染层，所以其数据必须是可以转成 JSON 的格式：字符串，数字，布尔值，对象，数组。 data: &#123; text: &quot;This is page data.&quot; &#125;, onLoad: function(options) &#123; // Do some initialize when page load.页面加载 &#125;, onReady: function() &#123; // Do something when page ready.页面初次渲染完成 &#125;, onShow: function() &#123; // Do something when page show.页面显示 &#125;, onHide: function() &#123; // Do something when page hide.页面隐藏 &#125;, onUnload: function() &#123; // Do something when page close.页面卸载 &#125;, onPullDownRefresh: function() &#123; // Do something when pull down.监听用户下拉动作 &#125;, onReachBottom: function() &#123; // Do something when page reach bottom.页面上拉触底事件的处理函数 &#125;, onShareAppMessage: function () &#123; // return custom share data when user share.用户点击右上角转发 return &#123; title: &apos;自定义转发标题&apos;, path: &apos;/page/user?id=123&apos; &#125; &#125;, onPageScroll: function() &#123; // Do something when page scroll.页面滚动触发事件的处理函数 &#125;, onTabItemTap(item) &#123; //当前是 tab 页时，点击 tab 时触发 //item : &#123; // index:&apos;&apos;, // pagePath:&apos;&apos;, // text:&apos;&apos; // &#125; &#125;, // Event handler. viewTap: function() &#123; this.setData(&#123; text: &apos;Set some data for updating view.&apos; &#125;, function() &#123; // this is setData callback &#125;) &#125;, customData: &#123; hi: &apos;MINA&apos; &#125;&#125;) 页面路由 小程序的页面路由是以栈的形式构建 123456当页面打开时页面栈形成，小程序首页入栈 | 栈的长度+1当打开新页面时，新页面入栈 | 栈的长度++ 直到栈的长度为5 * 第一个栈元素 为 首页栈页面重定向时，当前页面出栈，新页面入栈 | 栈的长度不变 页面返回时，页面不断出栈，直到目标返回页 | 栈的长度-- 直到栈的长度为1 Tab 切换时，页面全部出栈，只留下新的 Tab 页面 | 栈的长度重置 重加载时，页面全部出栈，只留下新的页面 | 栈的长度重置 Tip: navigateTo,redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 调用页面路由带的参数可以在目标页面的onLoad中获取。 模块化文件作用域 在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。 全局函数 getApp() 可以获取全局的应用实例模块化 可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。 推荐开发者采用 module.exports 来暴露模块接口 12345678// common.jsfunction sayHello(name) &#123; console.log(`Hello $&#123;name&#125; !`)&#125;function sayGoodbye(name) &#123; console.log(`Goodbye $&#123;name&#125; !`)&#125;module.exports.sayHello = sayHello 在需要使用这些模块的文件中，使用 require(path) 将公共代码引入,暂时不支持绝对路径 12345678910111213141516171819 var common = require(&apos;common.js&apos;) Page(&#123; helloMINA: function() &#123; common.sayHello(&apos;MINA&apos;) &#125;, goodbyeMINA: function() &#123; common.sayGoodbye(&apos;MINA&apos;) &#125; &#125;)``` #### 视图层##### wxml###### 数据绑定 这个就不详细介绍了，vue的绑定方式 &#123;&#123;&#125;&#125;组件属性(需要在双引号之内) ```html &lt;view id=&quot;item-&#123;&#123;id&#125;&#125;&quot;&gt; &lt;/view&gt; 列表渲染wx:for 在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item wx:key 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字 注意 花括号和引号之间如果有空格，将最终被解析成为字符串 条件渲染&gt; 对比 `wx-if` 与 `hidden` `wx:if` 有更高的切换消耗 `hidden` 有更高的初始渲染消耗 因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则 `wx:if` 较好。 事件 事件绑定和冒泡 bind 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡。 事件的捕获阶段 需要在捕获阶段监听事件时，可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段。 引用 import include include 可以将目标文件除了 &lt;template/&gt; &lt;wxs/&gt; 外的整个代码引入，相当于是拷贝到 include 位置]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>项目目录结构</tag>
        <tag>项目配置</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下用 Phaser 游戏框架的开发历程]]></title>
    <url>%2F2018%2F05%2F29%2Fblockchain%2F</url>
    <content type="text"><![CDATA[Phaser]]></content>
      <categories>
        <category>Phaser</category>
        <category>游戏框架</category>
      </categories>
      <tags>
        <tag>游戏框架</tag>
        <tag>工作经历</tag>
      </tags>
  </entry>
</search>
