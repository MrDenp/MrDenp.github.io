<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[axios 的封装]]></title>
    <url>%2F2018%2F08%2F08%2Faxios%2F</url>
    <content type="text"><![CDATA[一、axios的封装 在vue项目中，和后台交互数据主要是用的axios这个库，它是基于promise的http库，可以运行在浏览器端和node.js中。它有很多优秀的特性，例如拦截数据请求和响应、取消请求、转换json、客户端防御XSRF等等。 安装1npm install axios; // 安装axios 引入既然考虑到是封装这个请求的功能模块，我在项目的src目录中新建了一个request文件夹，里面放着两个JS文件，http.js 、api.js。http.js文件用来封装 axios ，api.js 用来统一管理接口。 http.js123456//首先需要引入axios 包import axios from 'axios';//引入qs模块，用来序列化post类型的数据import qs from 'qs'// 引入项目中的提示框组件，可以自己写也可以用UI 组件import &#123; Toast &#125; from 'vant' 环境的切换项目的环境会有开发环境、测试环境、生产环境。SO 这里用node的环境变量来匹配我们的默认接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址。 1234567891011// 环境的切换if (process.env.NODE_ENV == 'development') &#123; //开发 axios.defaults.baseURL = 'https://www.baidu.com';&#125; else if (process.env.NODE_ENV == 'debug') &#123; //测试 axios.defaults.baseURL = 'https://www.ceshi.com';&#125;else if (process.env.NODE_ENV == 'production') &#123; //生产 axios.defaults.baseURL = 'https://www.production.com';&#125; 设置请求超时通过axios.defaults.timeout设置默认的请求时间。如果请求时间超出，使用提示框提示用户请求超时，请刷新页面等等操作。 post请求头的设置post请求的时候，我们需要加上一个请求头，所以在这里可以进行一个默认的设置。即：设置默认请求头为 application/x-www-from-urlencoded;charset=UTF-8 1axios.defaults.headers.post['Content-Type'] = 'application/x-www-urlencoded;charset=UTF-8'; 请求拦截在发送请求前可以进行一个请求的拦截，为什么要拦截请求呢？因为在很多时候我们要判断用户是否登录，或者是post请求时，强制序列化请求数据。这个时候我们可以在请求被发送之前进行一个拦截，从而进行我们想要做的操作。 123456789101112131415161718192021222324 // 先导入vuex,因为我们要使用到里面的状态对象 // vuex的路径根据自己的路径去写 import store from &apos;@/store/index&apos;; // 请求拦截器axios.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断vuex中是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况 // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 const token = store.state.token; token &amp;&amp; (config.headers.Authorization = token); return config; &#125;, error =&gt; &#123; return Promise.error(error); &#125;)``` &gt; 这里需要特别说一下token ，一般是在登录完成之后，将用户的 token 保存在localStorage 或者 cookies 里，然后用户每次在进入页面的时候(即在main.js中)，会首先从本地存储中读取token,如果token存在说明用户已经登录过，则跟新vuex中的token的状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。在处理一些不需要登录的在后台接口去做判断就好了，我们带或不带都可以。## 响应的拦截响应的拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想，如果后台返回的状态码是200，则正常返回数据，否则根据错误的状态码类型进行一些错误处理，其实这里主要就是进行了统一的错误处理和登录与否是否登录信息过期的一个操作。 // 响应拦截器 axios.interceptors.response.use( response =&gt; { // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) { return Promise.resolve(response); } else { return Promise.reject(response); } }, // 服务器状态码不是2开头的的情况 // 这里可以跟你们的后台开发人员协商好统一的错误状态码 // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等 // 下面列举几个常见的操作，其他需求可自行扩展 error =&gt; { if (error.response.status) { switch (error.response.status) { // 401: 未登录 // 未登录则跳转登录页面，并携带当前页面的路径 // 在登录成功后返回当前页面，这一步需要在登录页操作。 case 401: router.replace({ path: &apos;/login&apos;, query: { redirect: router.currentRoute.fullPath } }); break; // 403 token过期 // 登录过期对用户进行提示 // 清除本地token和清空vuex中token对象 // 跳转登录页面 case 403: Toast({ message: &apos;登录过期，请重新登录&apos;, duration: 1000, forbidClick: true }); // 清除token localStorage.removeItem(&apos;token&apos;); store.commit(&apos;loginSuccess&apos;, null); // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 setTimeout(() =&gt; { router.replace({ path: &apos;/login&apos;, query: { redirect: router.currentRoute.fullPath } }); }, 1000); break; // 404请求不存在 case 404: Toast({ message: &apos;网络请求不存在&apos;, duration: 1500, forbidClick: true }); break; // 其他错误，直接抛出错误提示 default: Toast({ message: error.response.data.message, duration: 1500, forbidClick: true }); } return Promise.reject(error.response); } }, }); 12345678910111213141516171819## 封装get方法和post方法```javascript /** * get方法，对应get请求 * @param &#123;String&#125; url [请求的url地址] * @param &#123;Object&#125; params [请求时携带的参数] */ export function get(url, params)&#123; return new Promise((resolve, reject) =&gt;&#123; axios.get(url, &#123; params: params &#125;).then(res =&gt; &#123; resolve(res.data); &#125;).catch(err =&gt;&#123; reject(err.data) &#125;) &#125;);&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex -状态管理-]]></title>
    <url>%2F2018%2F07%2F16%2FVuex%2F</url>
    <content type="text"><![CDATA[VUEX 状态管理概述 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式.它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. 状态管理包括以下几个部分： state,驱动应用的数据源 view,以声明的方式将 state 映射到视图上 actions，响应在 view 上的用户输入导致的状态变化 大概了解了vuex状态管理，那什么时候该用 Vuex ？ 其实在比较简单的单页vue应用中,用状态管理是非常没必要的,这只会加重vue单页应用的复杂度,让整个项目更加繁琐冗余.所以在中大型项目中使用状态管理是最好的选择,这样可以让整个项目的管理便于管理. 废话不多说，从代码中实践才能出真理（ps：这是我从事开发这个行业以来总结出来的一句话，不喜勿喷~~） 如何使用首先是要使用这个vuex我们需要通过 npm 下载这个包 npm install vuex –save 安装完成就需要在项目结构中创建一个文件夹管理123456789101112131415- build- config- node_modules- src - assets - components - router - store /* 存放状态管理所有文件 */ - actions.js - getters.js - mutations.js - store.js /* 需要在main.js引入的模块 */ - App.vue - main.js- static 现在开始写vuex中几个js文件注意：写之前先把vuex注入整个项目工程中123456789// main.jsimport store from './store/index'new Vue(&#123; el: '#app', router, Store,//在这里注入状态管理 components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//./store/index.js import Vue from 'vue' import Vuex from 'vuex' import mutations from './mutations' import getters from './getters' import actions from './actions' Vue.use(Vuex) // 初始化一些常用数据，根据vue的理念，使用到的数据都必须先进行初始化设置。 let state = &#123; // 对话框 dialog: false, // 侧边栏 sidebar: &#123; open: false, docked: true &#125;, // 用户主页 personindex: false, // 搜索框 search: false, // 导航栏标题 headerTitle: 'Message', // 初始化基础数据 data: &#123; self: &#123;&#125;, friends: [] &#125;, // ajax请求数据是否结束 isAjax: false, // 当前被选中或者在聊天中的friend的_id activeId: 0, // 聊天队列，这里为每个朋友添加了一个聊天队列，偷懒写法，如果有需要可以改成动态添加 // _id是作为聊天队列的标记，list是聊天内容，list里的数据格式&#123;_id:xx, message:xxx&#125;,组件内会根据_id来将对话插入 // 到左边，还是右边，判断message是自己还是ai发出的 messageList: [ &#123; _id: 1, list: [&#123; _id: 1, message: '你可以和我聊天', time: '4:28' &#125;] &#125;, &#123; _id: 2, list: [&#123; _id: 2, message: '我会讲笑话哦', time: '9:50' &#125;] &#125;, &#123; _id: 3, list: [&#123; _id: 3, message: '请问你要来点兔子吗', time: '3:12' &#125;] &#125; ], // 消息队列副本，由于没有数据库，所以采用这样折中的方法 messageListFB: [ &#123; _id: 1, list: [&#123; _id: 1, message: '你可以和我聊天', time: '4:28' &#125;] &#125;, &#123; _id: 2, list: [&#123; _id: 2, message: '我会讲笑话哦', time: '9:50' &#125;] &#125;, &#123; _id: 3, list: [&#123; _id: 3, message: '请问你要来点兔子吗', time: '3:12' &#125;] &#125; ] &#125; // 导出一个新生成的Store对象 export default new Vuex.Store(&#123; state, mutations, actions, getters &#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 // actions.js// actions里存放的是异步操作// 由于vuex中的state的变更只能由mutations进行操作，所以actions不直接进行数据操作，而是调用mutations方法// 以下出现的that都是vue实例对象，因为把axios绑定在了Vue原型上，vuex无法调用，所以这里需要传入thisconst actions = &#123; // 异步获取基础数据 // 这里使用了es7的async函数，相当于封装了promis的generator getAllData: async (&#123; commit &#125;, that) =&gt; &#123; // 声明变量用来存放之后获得的数据 let self = &#123;&#125; let friends = &#123;&#125; await that.$http.get('/api/self') .then((&#123; data &#125;) =&gt; &#123; self = data.data &#125;) await that.$http.get('/api/friends') .then((&#123; data &#125;) =&gt; &#123; friends = data.data &#125;) commit('getData', &#123; self, friends &#125;) &#125;, // 聊天机器人 sendValue: async (&#123; commit &#125;, &#123; _id, message, that &#125;) =&gt; &#123; // 声明一个变量用来储存等下ajax获取的数据 let robotData = '' // 处理输入的内容，设置self为true，作为一个标记。 commit('changeList', &#123; self: true, _id, message &#125;) // 进行ajax请求，此处的that是从组件内传来的对象this await that.$http.get('/api/robotapi', &#123; params: &#123; message, id: _id &#125; &#125;).then(res =&gt; &#123; // 将获取到的数据赋值给先前设置的变量 robotData = JSON.parse(res.data.data) &#125;) // 判断获取到的数据类型，在进行对应操作 if (robotData.code === 100000) &#123; commit('changeList', &#123; _id, message: robotData.text &#125;) &#125; else if (robotData.code === 200000) &#123; let data = robotData.text + robotData.url commit('changeList', &#123; _id, message: data &#125;) &#125; else if (robotData.code === 302000) &#123; commit('changeList', &#123; _id, message: '暂不支持此类对话' &#125;) &#125; else &#123; commit('changeList', &#123; _id, message: '暂不支持此类对话' &#125;) &#125; &#125;&#125;export default actions 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// vuex中state的数据只能被mutations方法所更改// mutations.jsconst mutations = &#123; // 对话 showDialog: (state) =&gt; &#123; // 判断当前动作是否是在打开对话，如果是在打开对话，那么进行判断当前当前进行对话的好友是否存在消息队列 // 如果当前活跃的好友不存在消息队列（被删除的）那么就恢复此好友的消息队列，如果存在，那么无动作 if (!state.dialog) &#123; // 空数组用来判断也是true，所以后面加个[0] let message = state.messageList.filter(x =&gt; x._id === state.activeId)[0] if (!message) &#123; let oldMessage = state.messageListFB.filter(x =&gt; x._id === state.activeId)[0] state.messageList.splice(oldMessage._id - 1, 0, oldMessage) &#125; &#125; state.dialog = !state.dialog &#125;, // 侧边栏 showSidebar: (state, &#123; flag &#125; = &#123;&#125;) =&gt; &#123; state.sidebar.open = !state.sidebar.open state.sidebar.docked = !flag &#125;, // 个人主页 showPersonindex: (state) =&gt; &#123; state.personindex = !state.personindex &#125;, // 搜索 showSearch: (state) =&gt; &#123; state.search = !state.search &#125;, // ajax获取到用户数据 getData: (state, data) =&gt; &#123; // 将ajax获取到的值赋予state state.data = data // ajax状态更改为结束 state.isAjax = true &#125;, // 标题 changTitle: (state, &#123; title &#125;) =&gt; &#123; state.headerTitle = title &#125;, // 获取当前获得关注的朋友的_id getActiveId: (state, &#123; activeId &#125;) =&gt; &#123; state.activeId = activeId &#125;, // 消息队列，聊天队列处理 changeList: (state, obj) =&gt; &#123; let now = new Date() let time = `$&#123;now.getHours()&#125;:$&#123;now.getMinutes()&#125;` // 判断信息是自己的还是ai的，然后插入聊天队列中 if (obj.self) &#123; // 信息是自己发送的 state.messageList.forEach((item, index, arr) =&gt; &#123; if (item._id === obj._id) &#123; obj._id = 0 item.list.push(&#123; ...obj, time &#125;) &#125; &#125;) &#125; else &#123; // 信息是ai发送的 state.messageList.forEach((item, index, arr) =&gt; &#123; if (item._id === obj._id) &#123; item.list.push(&#123; ...obj, time &#125;) &#125; &#125;) &#125; &#125;, // 删除消息 removeMessage(state, &#123; _id &#125;) &#123; state.messageList.forEach((item, index, arr) =&gt; &#123; // 判断信息列表中id与正在删除的信息id是否相同，如果相同，就删除信息 if (item._id === _id) &#123; arr.splice(index, 1) &#125; &#125;) &#125;&#125;export default mutations 123456789101112131415161718192021// getter.js// 类似计算数据，根据state的数据，筛选或者暴露一格新数据const getters = &#123; // 根据当前选中的朋友的_id来筛选出当前的friend的具体数据 friend: (state) =&gt; &#123; return state.data.friends.filter(x =&gt; x._id === state.activeId)[0] &#125;, // 对当前消息队列中的消息进行加工，添加对应的好友资料 nowMessageList: (state) =&gt; &#123; let list = state.messageList list.forEach(x =&gt; &#123; // 由_id筛选出对应的好友 let friend = state.data.friends.filter(i =&gt; i._id === x._id)[0] x.friend = friend &#125;) return list &#125;&#125;export default getters]]></content>
      <categories>
        <category>vue</category>
        <category>状态管理Vuex</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>状态管理Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装一个倒计时插件]]></title>
    <url>%2F2018%2F07%2F04%2FcountTime%2F</url>
    <content type="text"><![CDATA[倒计时设定时长 这种主要是通过设置时间长度进行倒计时 分析流程 countTime(options){} 首先封装的功能模块所传的参数主要有时间长度，设定以 s（秒） m（分） h（时） d（天）等关键字为一个参数，默认为 s（秒）; 接下来我们需要确认的是该功能模块设置倒计时该如何显示到页面中？这里我的想法是将显示倒计时设置到每个指定的元素中，这些元素通过一个数组参数进行设置[s,m,h,d]; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107function CountTime(options)&#123; if(new Date(options.endTime.replace(/-/g, "/")).getTime() &lt; Date.now())&#123; // alert("截止时间早于当前时间，请重新设置！"); return ; &#125; this.timeNum = options.TimeNum || 0; this.ElementArray = options.ElementArray; this.timesObj; this.TimeStr = options.TimeStr || "s"; this.endTimeFlag = options.endTimeFlag || false; this.curTime; this.endTime; this.s = 0; this.m = 0; this.h = 0; this.d = 0; this.init = function()&#123; this.curTime = new Date().getTime(); if(!this.endTimeFlag)&#123; if(this.TimeStr === "s")&#123; this.endTime = this.curTime*1 + (this.timeNum * 1000); this.setTime(this.endTime-this.curTime*1); &#125;else if(this.TimeStr === "m")&#123; this.endTime = this.curTime*1 + (this.timeNum * 1000 * 60); this.setTime(this.endTime-this.curTime*1); &#125;else if(this.TimeStr === "h")&#123; this.endTime = this.curTime + (this.timeNum * 1000 * 60 * 60); this.setTime(this.endTime-this.curTime*1); &#125;else if(this.TimeStr === "d")&#123; this.endTime = this.curTime*1 + (this.timeNum * 1000 * 60 * 60 * 24); this.setTime(this.endTime-this.curTime*1); &#125; &#125;else&#123; if(options.endTime)&#123; this.endTime = new Date(options.endTime.replace(/-/g, "/")).getTime();//此处做了移动端 ios Date对象的兼容处理。 &#125;else&#123; console.log("请设置 ‘endTime’ 项，否则请将 'endTimeFlag' 设置为false或不写，不写默认为false") &#125; &#125; this.interval(); return this; &#125;; this.setTime = function(times)&#123; this.d = Math.floor(times/1000/60/60/24) &gt; 0 ? Math.floor(times/1000/60/60/24) : 0; if(Math.floor(times/1000/60/60) &gt; 0)&#123; this.h = Math.floor(times/1000/60/60%24) &lt; 10 ? "0"+Math.floor(times/1000/60/60%24): Math.floor(times/1000/60/60%24); &#125;else &#123; this.h = "00"; &#125; if(Math.floor(times/1000/60) &gt; 0)&#123; this.m = Math.floor(times/1000/60%60) &lt; 10 ? "0"+Math.floor(times/1000/60%60): Math.floor(times/1000/60%60); &#125;else &#123; this.m = "00"; &#125; if(Math.floor(times/1000) &gt; 0)&#123; this.s = Math.floor(times/1000%60) &lt; 10 ? "0"+Math.floor(times/1000%60): Math.floor(times/1000%60); &#125;else &#123; this.s = 0; &#125; &#125;; this.setElement = function()&#123; let that = this; if(that.ElementArray.length === 1)&#123; $(that.ElementArray[0]).html(this.d) &#125;else if(that.ElementArray.length === 2)&#123; $(that.ElementArray[0]).html(this.d); $(that.ElementArray[1]).html(this.h); &#125;else if(that.ElementArray.length === 3)&#123; $(that.ElementArray[0]).html(this.d); $(that.ElementArray[1]).html(this.h); $(that.ElementArray[2]).html(this.m); &#125;else if(that.ElementArray.length === 4)&#123; $(that.ElementArray[0]).html(this.d); $(that.ElementArray[1]).html(this.h); $(that.ElementArray[2]).html(this.m); $(that.ElementArray[3]).html(this.s); &#125; &#125;; this.interval = function()&#123; let that = this; let timer = setInterval(function()&#123; that.curTime = new Date().getTime(); if(that.s &lt; 0)&#123; clearInterval(timer) &#125;else&#123; that.setTime(that.endTime-that.curTime); that.setElement(); that.timesObj =&#123; days:that.d, hours:that.hours, minutes:that.m, second: that.s &#125; &#125; &#125;,1000) &#125;&#125;/*使用方法:let timers = new CountTime(&#123; TimeNum: 5, ElementArray:[".day",".hour",".min",".sec"], TimeStr:"h"&#125;).init();*/]]></content>
      <categories>
        <category>JS封装</category>
      </categories>
      <tags>
        <tag>倒计时</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 从零开始了解微信小程序的开发（二）]]></title>
    <url>%2F2018%2F06%2F30%2FWeChatSmallProgram1%2F</url>
    <content type="text"><![CDATA[这个项目周期可能会很久，毕竟我只是一个前端，后台那部分还需要边学边开发。 项目需求 项目需求：首先开发这个项目 目的是什么？ 项目UI项目配置使用iconfont字体图标123456789/* app.wxss */ @font-face &#123; font-family: 'iconfont'; /* project id 431644 */ src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot'); src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.woff') format('woff'), url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.ttf') format('truetype'), url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.svg#iconfont') format('svg'); &#125; 12345678/*初始化样式*/.icon&#123; display: inline-block; font-family: 'iconfont';&#125;.icon-home::before&#123; content: "\e600";&#125; 1&lt;view class="icon icon-home"&gt;&lt;/view&gt; 项目开发前端后台项目提交项目总结]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>实战项目</tag>
        <tag>展示类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DailyCase-devicemotion]]></title>
    <url>%2F2018%2F06%2F22%2FDailyCase-devicemotion%2F</url>
    <content type="text"><![CDATA[重力感应事件相关文档### 应用小案例]]></content>
      <categories>
        <category>每日一更demo</category>
      </categories>
      <tags>
        <tag>H5之重力感应事件</tag>
        <tag>前端案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typed.js 一个实现打字机效果的库]]></title>
    <url>%2F2018%2F06%2F19%2FTyped-js%2F</url>
    <content type="text"><![CDATA[Typed.js 使用Typed.js 库的安装安装NPM:1npm install typed.js Yarn1yarn add typed.js Bower1bower install typed.js Setup1234567// Can also be included with a regular script tagimport Typed from &apos;typed.js&apos;;var options = &#123; strings: [&quot;&lt;i&gt;First&lt;/i&gt; sentence.&quot;, &quot;&amp;amp; a second sentence.&quot;], typeSpeed: 40&#125;var typed = new Typed(&quot;.element&quot;, options); 实例化HTML12345&lt;div id="typed-strings"&gt; &lt;p&gt;Typed.js is a &lt;strong&gt;JavaScript&lt;/strong&gt; library.&lt;/p&gt; &lt;p&gt;It &lt;em&gt;types&lt;/em&gt; out sentences.&lt;/p&gt;&lt;/div&gt;&lt;span id="typed"&gt;&lt;/span&gt; javascript12345&lt;script&gt; var typed = new Typed(&apos;#typed&apos;, &#123; stringsElement: &apos;#typed-strings&apos; &#125;);&lt;/script&gt; 配置12345678910111213141516&#123;//数组类型,里面存放文本内容，输出的文本。从下标0开始，打印第一个，从新覆盖，打印出第二个。注意：输出标签时，在input会直接输出标签，如果在一个div内，会当标签执行掉 strings: [&quot;These are the default values...&quot;, &quot;You know what you should do?&quot;, &quot;Use your own!&quot;, &quot;Have a great day!&quot;], backSpeed: 60, //删除字的速度 startDelay: 100, //每一句开始打字停顿的时间 backDelay: 500, //每一句删除字的停顿时间 loop: true, //是否循环动画 loopCount: 5/Infinity, //循环次数 showCursor: true, //是否显示光标 cursorChar: &quot;︳&quot;, //设置光标字符 autoInsertCss: false, fadeOut boolean, //类型，开启运动效果，==和下面的fadeOutClass和fadeOutDelay才能看出效果== fadeOutClass:’typed-fade-out’, //string 类型，比如：’typed-fade-out’值 fadeOutDelay: 500, //number 类型，设置淡出为毫秒为单位。&#125; 对这个库的分析理解 起初看到这个插件库的时候我以为可以控制每段文字是否可以回删，后来仔细的了解之后，额是我想多了，那种每段文字有时间间隔 有换行的那种效果其实是某一个元素中的处理。 例如：12strings : [&quot;事业和爱情.^2000\n我爱写程序.^2000\n我爱做很Cool的东西.^2000\n谢谢...&quot;],//这里的 ^2000 是指定的间隔时间 \n 换行 案例开发 现在我想做一个输出一段代码，并且这段代码的样式像编辑器里的代码样式那样，有各式各样的样式区分，这里首先想到的一个难点是，在这个插件解析输入的文本时除了input标签里会把标签当做字符串输出来，其他的标签则会解析对应的标签，这个问题该如何解决？ 案例的需求分析 既然有了这样的需求，那么就想办法解决一下完成这个需求中的难点 难点解决 这个难点的问题在于标签在除 input 标签里都会发生标签的解析，这样我们在输出的文本中就无法完成标签的显示，其实在配置项中有个配置叫做 contentType 默认设置为 html,当我们不需要解析标签时将其设置为 ‘null’ 就ok了,但是这样又存在一个问题，这样做的结果是所有的标签都不会解析了，如果说我们需要设置样式的话就没办法完成了。很痛苦啊。12关键的一点就是这个了strings : [`&lt;span style=&apos;color: #8ba7c9;&apos;&gt;&lt;&lt;span style=&apos;color: #dd6655&apos;&gt;span&lt;/span&gt;&gt;&lt;span style=&quot;color:#fff&quot;&gt;这是输出的span标签里的内容&lt;/span&gt;&lt; /&lt;span style=&apos;color: #dd6655&apos;&gt;span&lt;/span&gt;&gt;&lt;/span&gt;^2000`],]]></content>
      <categories>
        <category>实现一个打字机效果小案例</category>
      </categories>
      <tags>
        <tag>前端库</tag>
        <tag>Typed.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[compatibility 工作中遇到的一些问题]]></title>
    <url>%2F2018%2F06%2F15%2Fcompatibility%2F</url>
    <content type="text"><![CDATA[兼容IOS new Date() 在ios中不识别 2018-06-14 中的‘-’，只识别‘/’，当时做项目的时候在模拟机上测试没有问题，安卓也没有问题，但是一上ios真机就bug了，很难受，最后还是alert() 出 new Date(2018-06-14 23:00:00) 的时候为 invalid date,这才发现问题。 let 关键字 不兼容9.3以下版本安卓工作中遇到的一些问题样式css处理文字超出部分显示省略号1.单行12345span&#123; overflow: hidden; text-overflow:ellipsis; white-space: nowrap;&#125; 2.多行123456span&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden;&#125; 注意： 在vue等js框架中编译打包后浏览器不识别，可能是由于文件中的注释耦合。 解决办法就是将样式直接写在行内样式里，这样的话会避免这种BUG。 css写个小三角123456789#item&#123; width: 0; height: 0; border-top: 50px solid transparent; border-bottom: 50px solid #002884; border-left: 50px solid transparent; border-right: 50px solid transparent; background: #ffffff;&#125; 逻辑js摇一摇代码1234567891011121314151617181920212223if (window.DeviceMotionEvent) &#123; window.addEventListener('devicemotion',deviceMotionHandler, false); &#125; var speed = 38;//speed var x = y = z = lastX = lastY = lastZ = 0; function deviceMotionHandler(eventData) &#123; var acceleration =eventData.accelerationIncludingGravity; x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX) &gt; speed || Math.abs(y-lastY) &gt; speed || Math.abs(z-lastZ) &gt; speed) &#123; //简单的摇一摇触发代码 num++;//摇一摇次数 if(num&gt;100)&#123; window.removeEventListener('devicemotion',deviceMotionHandler, false); &#125; $('.num').text(num); &#125; lastX = x; lastY = y; lastZ = z; &#125; 数组统计数组中相同项的个数 很多时候，你希望统计数组中重复出现项的个数然后用一个对象表示。那么你可以使用reduce方法处理这个数组。 123456var cars = ['BMW','Benz', 'Benz', 'Tesla', 'BMW', 'Toyota'];var carsObj = cars.reduce(function (obj, name) &#123; obj[name] = obj[name] ? ++obj[name] : 1; return obj;&#125;, &#123;&#125;);carsObj; // =&gt; &#123; BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 &#125; Set实现数组去重 在ES6中，因为Set只存储唯一值，所以你可以使用Set删除重复项。 12let arr = [1, 1, 2, 2, 3, 3];let deduped = [...new Set(arr)] // [1, 2, 3] 对Set使用数组方法 使用扩展运算符就可以简单的将Set转换为数组。所以你可以对Set使用Array的所有原生方法。 12let mySet = new Set([1,2, 3, 4, 5]);var filtered = [...mySet].filter((x) =&gt; x &gt; 3) // [4, 5] 对象使用解构删除不必要属性 有时候你不希望保留某些对象属性，也许是因为它们包含敏感信息或仅仅是太大了。你可能会枚举整个对象然后删除它们，但实际上只需要简单的将这些无用属性赋值给变量，然后把想要保留的有用部分作为剩余参数就可以了。 123let &#123;_internal, tooBig, ...cleanObject&#125; = &#123;el1: '1', _internal:"secret", tooBig:&#123;&#125;, el2: '2', el3: '3'&#125;;console.log(cleanObject); // &#123;el1: '1', el2: '2', el3: '3'&#125; 合并对象 ES6带来了扩展运算符（…）。它一般被用来解构数组，但你也可以用它处理对象。 1234let object1 = &#123; a:1, b:2,c:3 &#125;let object2 = &#123; b:30, c:40, d:50&#125;let merged = &#123;...object1, ...object2&#125; //spread and re-add into mergedconsole.log(merged) // &#123;a:1, b:30, c:40, d:50&#125; 密封的对象 密封对象不可扩展，且不能删除属性和方法 12345678let person = &#123; name: 'addone' &#125;;Object.seal(person);person.age = 20;delete person.name;person.age // undefinedperson.name // addone 相对的也有Object.isSealed()来判断是否密封 冻结的对象 这是最严格的防篡改级别，冻结的对象即不可扩展，又密封，且不能修改 123456789let person = &#123; name: 'addone' &#125;;Object.freeze(person);person.age = 20;delete person.name;person.name = 'addtwo'person.age // undefinedperson.name // addone **同样也有` Object.isFrozen `来检测** JS小数计算不准确的bug1234567console.log(0.1 + 0.2);console.log(0.1 + 0.2 == 0.3);//答案: 0.30000000000000004 false//解决办法parseFloat((0.1+0.2).toFixed(10)); VUEvue中的 keep-alive keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。 注意：当组件在 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。 关于 Vue2.0 路由开启 keep-alive 时需要注意的地方 首次进来 hook 的触发顺序 created-&gt; mounted-&gt; activated，退出时触发 deactivated： 二次进来 hook 只触发 activated，退出时触发 deactivated： 注意：在开启keep-alive时最好把请求数据写在 activated 生命周期中，这样在首次加载页面的时候不会请求多次数据，优化一点性能. 1234567891011121314151617&lt;!-- 基本 --&gt;&lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt; &lt;comp-a v-if=&quot;a &gt; 1&quot;&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; include 和 exclude 1234567891011121314&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 这里可以使用路由中的路由元信息 meta 来设置是否使用比如 可以在配置某个路由时设置 123456789101112const routes= [&#123; path: '/article', name: 'article', meta: &#123; login: true, keepAlive:true,//在需要使用keep缓存的路由组件中配置该项，然后在 APP.vue 中使用$route.meta.keepAlive 做是否加载keepAlive &#125;, components: &#123; container: Article, footer: Mainfooter &#125;&#125;]; vue 进入/离开 &amp; 列表过渡概述Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：在 CSS 过渡和动画中自动应用 class可以配合使用第三方 CSS 动画库，如 Animate.css在过渡钩子函数中使用 JavaScript 直接操作 DOM可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡 12345678&lt;div id="demo"&gt; &lt;button v-on:click="show = !show"&gt; Toggle &lt;/button&gt; &lt;transition name="fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#demo', data: &#123; show: true &#125;&#125;) 123456.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s;&#125;.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123; opacity: 0;&#125; CSS 过渡 常用的过渡都是使用 CSS 过渡。 12345678&lt;div id="example-1"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;transition name="slide-fade"&gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-1', data: &#123; show: true &#125;&#125;) 12345678910111213/* 可以设置不同的进入和离开动画 *//* 设置持续时间和动画函数 */.slide-fade-enter-active &#123; transition: all .3s ease;&#125;.slide-fade-leave-active &#123; transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);&#125;.slide-fade-enter, .slide-fade-leave-to/* .slide-fade-leave-active for below version 2.1.8 */ &#123; transform: translateX(10px); opacity: 0;&#125; CSS 动画 CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend 事件触发时删除。 123456&lt;div id="example-2"&gt; &lt;button @click="show = !show"&gt;Toggle show&lt;/button&gt; &lt;transition name="bounce"&gt; &lt;p v-if="show"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-2', data: &#123; show: true &#125;&#125;) 1234567891011121314151617.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125; 自定义过渡的类名 我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。 1234567891011121314&lt;link href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1" rel="stylesheet" type="text/css"&gt;&lt;div id="example-3"&gt; &lt;button @click="show = !show"&gt; Toggle render &lt;/button&gt; &lt;transition name="custom-classes-transition" enter-active-class="animated tada" leave-active-class="animated bounceOutRight" &gt; &lt;p v-if="show"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-3', data: &#123; show: true &#125;&#125;) 显性的过渡持续时间 123&lt;transition :duration="1000"&gt;...&lt;/transition&gt;&lt;!--定制一套属于自己的 过渡时间--&gt;&lt;transition :duration="&#123; enter: 500, leave: 800 &#125;"&gt;...&lt;/transition&gt; JavaScript 钩子 12345678910111213&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748new Vue(&#123; el: '#example-3', data: &#123; show: true &#125;, methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125; &#125;&#125;) 注意： 当只用 JavaScript 过渡的时候，在 enter 和 leave 中必须使用 done 进行回调。否则，它们将被同步调用，过渡会立即完成。 vue 中通过webpack全局引入jQuery 通过npm安装jQuery组件：npm i jquery --save 在 build/webpack.base.conf.js 里加入: const webpack = require(&quot;webpack&quot;)123456789101112131415161718192021222324module.exports = &#123; // 其他代码... resolve: &#123; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.vue&apos;], fallback: [path.join(__dirname, &apos;../node_modules&apos;)], alias: &#123; &apos;src&apos;: path.resolve(__dirname, &apos;../src&apos;), &apos;assets&apos;: path.resolve(__dirname, &apos;../src/assets&apos;), &apos;components&apos;: path.resolve(__dirname, &apos;../src/components&apos;), // webpack 使用 jQuery，如果是自行下载的 // &apos;jquery&apos;: path.resolve(__dirname, &apos;../src/assets/libs/jquery/jquery.min&apos;), // 如果使用NPM安装的jQuery &apos;jquery&apos;: &apos;jquery&apos; &#125; &#125;, // 增加一个plugins plugins: [ new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;, jQuery: &quot;jquery&quot; &#125;) ], // 其他代码...&#125;; 重新运行 npm run dev vue- 样式问题vue- scoped 在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于当前的Vue组件，可以使组件的样式不相互污染。如果一个项目的所有style标签都加上了scoped属性，相当于实现了样式的模块化。 scoped 实现原理：Vue中的scoped属性的效果主要是通过PostCss实现的。PostCss给组件中的所有dom元素添加了一个独一无二的动态属性值，给所有的css选择器添加了一个对应的属性选择器，进而选择对应组件中的dom元素，所以对应的样式作用于对应的组件。 vue- scoped穿透 scoped穿透主要是解决在项目中用到第三方组件库的时候，需要在局部组件中修改第三方组件的样式，又不想去掉scoped属性造成组件之间的样式覆盖污染。 解决方法 在 stylus 中的样式穿透： &gt;&gt;&gt; 1234.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background: #fff``` - 在 sass 和 less 的样式穿透 使用 `/deep/` .wrapper /deep/ .swiper-pagination-bullet-active{ background: #fff; }` 其他]]></content>
      <categories>
        <category>前端兼容问题</category>
        <category>css样式处理</category>
      </categories>
      <tags>
        <tag>ios兼容</tag>
        <tag>安卓兼容</tag>
        <tag>vue</tag>
        <tag>vue 组件过渡效果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FrontEndResources 资源积累]]></title>
    <url>%2F2018%2F06%2F12%2FFrontEndResources%2F</url>
    <content type="text"><![CDATA[一组资源分享开发类前端库 实现打字机的效果 💎 Three.js-3D-手册 💎工具1.图片压缩网站 💎2.平面设计网站 💎3.8000个分类好的icon 💎框架构建部署后端设计类色彩 非常好用的渐变色网站 WebGradients.com 💎 ColorDrop - New colors 免费的图片资源网站-PEXELS规范其他类]]></content>
      <categories>
        <category>资源积累</category>
      </categories>
      <tags>
        <tag>色彩搭配</tag>
        <tag>开发库资源</tag>
        <tag>开发组件资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉一个节约开发时间的库和资源]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%8B%89%E4%B8%80%E4%B8%AA%E8%8A%82%E7%BA%A6%E5%BC%80%E5%8F%91%E6%97%B6%E9%97%B4%E7%9A%84%E5%BA%93%E5%92%8C%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[JavaScript 库Particles.js 在网页上创建炫酷的漂浮例子的库，在网站首页比较常见。 Three.js 在网页上创建 3D 对象和空间的库，常用于网页游戏。 Fullpage.js 轻松创建全屏滚动的网页。 Typed.js 实现打字机的效果。 Waypoints.js 实现滚动一个元素触发一个函数的最简单的方式。 Highlight.js 自动检测语言及高亮语法。 Chart.js 纯 JavaScript 实现炫酷图表。 Instantclick 大大提升网页加载效率，在鼠标悬停时预加载资源。 Chartist 另一个图表库。 Motio 实现基于 sprite 的动画和平移效果的库。 Animstion css 动画页面切换效果的 JQuery 插件 Barba.js 流畅和平滑的页面过渡效果。 TwentyTwenty 一个视觉差异工具，突出两个图像之间的差异。 Vivus.js 用于在 SVG 上绘制动画的库。 Wow.js 滚动时显示动画。 Scrolline.js 显示页面的滚动进度条。 Velocity.js 快速、平滑的 JavaScript 动画。 Animate on scroll 另一个滚动显示动画的库。 Handlebars.js —— JavaScript 模版。 jInvertScroll —— 轻量级的水平视差插件。 One page scroll —— 与 FullPage 类似。 Parallax.js —— 视觉引擎，对智能设备的方向做出反应。 Typeahead.js —— 自动匹配搜索。 Dragdealer.js —— 相当酷的实现拖动效果的库。 Bounce.js —— 创建炫酷的 CSS3 动画。 Pagepiling.js —— 又一个 one page scroll. Multiscroll.js —— 实现多列滚动面板效果。 Favico.js —— 动态图标。 Midnight.js —— 无缝切换固定标题。 Anime.js —— 动画库。 Keycode —— 获得按键的 JavaScript 键码。 Sortable —— 拖动排序控件。 Flexdatalist —— 输入补全。 Slideout.js —— 在网页上实现抽屉效果的侧边导航栏。 Jquerymy —— 使用 jquery 的两种数据绑定方式。 Cleave.js —— 格式化输入内容。 Page —— 小型客户端路由库。 Selectize.js —— 用于添加标签的选择框。 Nice select —— 用于创建奈斯型选择框。 Tether —— 可以有效地固定绝对定位的元素。 Shepherd.js —— 实现指导用户使用应用的效果。 Tooltip —— 提示信息。 Select2 —— 丰富的自定义选择框。 IziToast —— 容易实现的 JS 通知。 IziModal —— 容易实现的 JS 弹窗。 CSS 库／设计类Animate.css —— 动画库。 Flat UI Colors —— 简单有效的颜色。 Material design lite —— 基于 Google 的 Material Design。 Materialui.co —— 许多 Material Design 框架的资源。 Colorrrs —— 随机颜色生成器。 Section separators —— CSS 分割线。 Topcoat —— 简单快速的 CSS 框架。 Create ken burns effect —— 使用 CSS 动画的 Ken Burns 效果。 DynCSS —— 为 CSS 添加函数，让它变成动态的。 Magic animations —— 人如其名。 CSSpin —— CSS 旋转控件集合。 Feather icons —— 图标。 Ion icons —— 图标。 Font awesome —— 图标。 Font generator —— 组合多种字体，生成一个混合体。 On/Off switch —— 开关按钮。 UI Kit —— 轻型的模块化框架。 Bootstrap —— 这个就不谈了。 Foundation —— 号称最先进的响应式前端框架。]]></content>
      <categories>
        <category>节约开发时间成本的资源清单</category>
      </categories>
      <tags>
        <tag>js库</tag>
        <tag>css 库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD - 异步模块定义]]></title>
    <url>%2F2018%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[AMD 是”Asynchronous Module Definition”的缩写,意思就是”异步模块定义“.它采用异步方式加载模块,模块的加载不会影响它后面程序语句的运行.所有依赖这个模块的语句,都定义在一个回调函数中,等到加载完成之后这个回调函数才会运行. AMD如何加载模块 AMD 也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：1require([module], callback); 第一个参数[module],是一个数组，数组元素就是需要依赖的加载模块,第二个参数是一个回调函数,这个回调函数在第一个参数中的模块加载成功之后才会执行.例如123require([&apos;math&apos;],function(math)&#123; math.add(2,3);&#125;) 注意 此时math.add()与math模块加载不是同步的,浏览器不会发生请求数据时的假死状态. require.js 之前文件中一次加载很多js文件的写法有很大的缺点,加载的时候,浏览器会停止网页渲染,所以加载的文件越多,网页失去响应的时间就会越长,由于js文件之间存在依赖关系,因此在依赖关系复杂的时候代码的而编写就会变得很困难. require JS 的诞生主要解决了两个问题 实现js文件的异步加载,避免网页失去响应; 管理模块之间的依赖性,便于代码的编写和维护; require.js 的加载 两种引入方式： 1.在文件头部引入时需要异步加载并且如要兼容IE则需要加defer 1&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt; 2.在页面底部引入 引入require.js后就需要引入自己的js文件了 1&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; data-main 属性的作用是,指定网页程序的主模块.main.js会被require加载,由于require 默认的文件后缀是js,所以可以把main.js写成main1234567891011121314151617require.config(&#123; baseUrl: &quot;js/lib&quot;,//指定js加载的基目录 paths: &#123; &quot;jquery&quot;: &quot;jquery.min&quot;, &quot;underscore&quot;: &quot;underscore.min&quot;, &quot;backbone&quot;: &quot;backbone.min&quot; &#125;， shim:&#123;//这个属性是专门用来配置不兼容的模块1exports暴露出去的变量名称，deps数组表明该模块的依赖 &apos;jquery.scroll&apos;:&#123; deps:[&apos;jquery&apos;], exports:&apos;jQuery.fn.scroll&apos; &#125; &#125;&#125;);require([&apos;jquery&apos;,&apos;uderscore&apos;,&apos;backbone&apos;],function($,_,Backbone)&#123; &#125;)]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序 从零开始了解微信小程序的开发（一）]]></title>
    <url>%2F2018%2F06%2F06%2FWeChatSmallProgram%2F</url>
    <content type="text"><![CDATA[摘要：记录这个一是帮助更多从零开始的开发小白可以通俗易懂的了解小程序开发，另外一个目的就是对小程序开发从零开始总结梳理一下，帮助别人的同时提升自己。（ps - 在总结中成长，不论是任何行业都适用的一句真言。） 微信小程序框架部分目录结构 pages index index.wxml index.wxss index.js logs app.js app.json app.wxss 配置 app.json pages 接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。 123456&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ]&#125; window 1234567891011&#123; &quot;window&quot;:&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;navigationStyle&quot;: &quot;custom&quot;, &quot;enablePullDownRefresh&quot;: false &#125;&#125; tabBar 如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 注意：当设置 position 为 top 时，将不会显示 icon，list是一个数组，该数组最少配置2个tab，最多5个tab，tab按照数组的顺序进行排列。 1234567891011121314151617&#123; &quot;tabBar&quot;:&#123; &quot;position&quot;:&quot;bottom&quot;, &quot;borderStyle&quot;:&quot;black&quot;, &quot;color&quot;:&quot;#FFF&quot;, &quot;selectedColor&quot;:&quot;#333&quot;, &quot;list&quot;:[ &#123; &quot;text&quot;:&quot;首页&quot;, &quot;pagePath&quot;:&quot;pages/index/index&quot;, &quot;iconPath&quot;:&quot;/static/images/index.png&quot;, &quot;selectedIconPath&quot;:&quot;/static/images/index.png&quot; &#125;, ], &quot;backgroundColor&quot;:&quot;#efefef&quot; &#125;&#125; networkTimeout 可以设置各种网络请求的超时时间。 12345678&#123; &quot;networkTimeout&quot;:&#123; &quot;request&quot;: 6000, &quot;connectSocket&quot;: 6000, &quot;uploadFile&quot;: 6000, &quot;downloadFile&quot;: 6000, &#125;&#125; page.json 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。 页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 12345678910&#123; &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;, &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;, &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, &quot;backgroundTextStyle&quot;: &quot;light&quot;, &quot;enablePullDownRefresh&quot;: false, &quot;disableScroll&quot;: false,//true 设置页面整体不能上下滚动，仅设置在page.json &quot;onReachBottomDistance&quot;: 50 &#125; 框架逻辑层注册程序 APP() 函数用来注册一个小程序。接收一个object参数。 1234567891011121314App(&#123; onlaunch()&#123; //监听一个小程序的初始化，全局只触发一次 `生命周期函数` &#125;， onShow()&#123; //监听一个小程序的页面显示的 `生命周期函数` &#125;, onHide()&#123; //监听一个小程序的页面隐藏的 `生命周期函数` &#125;, onPageNotFound()&#123; //监听一个小程序的页面不存在的 `生命周期函数` &#125;&#125;) 场景值|场景值|说明| |:-------:|:---:| |1001|发现栏小程序主入口| |1005|顶部搜索框的搜索结果页| |1006|发现栏小程序主入口搜索框的搜索结果页| |1007|单人聊天会话中的小程序消息卡片| |1008|群聊会话中的小程序消息卡片| |1011|扫描二维码| |1012|长按图片识别二维码| |1013|手机相册选取二维码| |1014|小程序模版消息| |1017|前往体验版的入口页| |1019|微信钱包| |1020|公众号 profile 页相关小程序列表| |1022|聊天顶部置顶小程序入口| |1023|安卓系统桌面图标| |1024|小程序 profile 页| |1025|扫描一维码| |1026|附近小程序列表| |1027|顶部搜索框搜索结果页“使用过的小程序”列表| |1028|我的卡包| |1031|长按图片识别一维码| |1032|手机相册选取一维码| |1036|App 分享消息卡片| |1044|带 shareTicket 的小程序消息卡片（详情)| |1047|扫描小程序码| |1089|微信聊天主界面下拉| |1090|长按小程序右上角菜单唤出最近使用历史| 注册页面 Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。 onShareAppMessage() : 用户转发 只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮 用户点击转发按钮的时候会调用 此事件需要 return 一个 Object，用于自定义转发内容 Object自定义转发字段 title 转发标题 默认当前小程序的名称path 转发路径 默认当前页面path，必须是以/开头的完整路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Page(&#123;//data 将会以 JSON 的形式由逻辑层传至渲染层，所以其数据必须是可以转成 JSON 的格式：字符串，数字，布尔值，对象，数组。 data: &#123; text: &quot;This is page data.&quot; &#125;, onLoad: function(options) &#123; // Do some initialize when page load.页面加载 &#125;, onReady: function() &#123; // Do something when page ready.页面初次渲染完成 &#125;, onShow: function() &#123; // Do something when page show.页面显示 &#125;, onHide: function() &#123; // Do something when page hide.页面隐藏 &#125;, onUnload: function() &#123; // Do something when page close.页面卸载 &#125;, onPullDownRefresh: function() &#123; // Do something when pull down.监听用户下拉动作 &#125;, onReachBottom: function() &#123; // Do something when page reach bottom.页面上拉触底事件的处理函数 &#125;, onShareAppMessage: function () &#123; // return custom share data when user share.用户点击右上角转发 return &#123; title: &apos;自定义转发标题&apos;, path: &apos;/page/user?id=123&apos; &#125; &#125;, onPageScroll: function() &#123; // Do something when page scroll.页面滚动触发事件的处理函数 &#125;, onTabItemTap(item) &#123; //当前是 tab 页时，点击 tab 时触发 //item : &#123; // index:&apos;&apos;, // pagePath:&apos;&apos;, // text:&apos;&apos; // &#125; &#125;, // Event handler. viewTap: function() &#123; this.setData(&#123; text: &apos;Set some data for updating view.&apos; &#125;, function() &#123; // this is setData callback &#125;) &#125;, customData: &#123; hi: &apos;MINA&apos; &#125;&#125;) 页面路由 小程序的页面路由是以栈的形式构建 123456当页面打开时页面栈形成，小程序首页入栈 | 栈的长度+1当打开新页面时，新页面入栈 | 栈的长度++ 直到栈的长度为5 * 第一个栈元素 为 首页栈页面重定向时，当前页面出栈，新页面入栈 | 栈的长度不变 页面返回时，页面不断出栈，直到目标返回页 | 栈的长度-- 直到栈的长度为1 Tab 切换时，页面全部出栈，只留下新的 Tab 页面 | 栈的长度重置 重加载时，页面全部出栈，只留下新的页面 | 栈的长度重置 Tip: navigateTo,redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 调用页面路由带的参数可以在目标页面的onLoad中获取。 模块化文件作用域 在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。 全局函数 getApp() 可以获取全局的应用实例模块化 可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。 推荐开发者采用 module.exports 来暴露模块接口 12345678// common.jsfunction sayHello(name) &#123; console.log(`Hello $&#123;name&#125; !`)&#125;function sayGoodbye(name) &#123; console.log(`Goodbye $&#123;name&#125; !`)&#125;module.exports.sayHello = sayHello 在需要使用这些模块的文件中，使用 require(path) 将公共代码引入,暂时不支持绝对路径 12345678910111213141516171819 var common = require(&apos;common.js&apos;) Page(&#123; helloMINA: function() &#123; common.sayHello(&apos;MINA&apos;) &#125;, goodbyeMINA: function() &#123; common.sayGoodbye(&apos;MINA&apos;) &#125; &#125;)``` #### 视图层##### wxml###### 数据绑定 这个就不详细介绍了，vue的绑定方式 &#123;&#123;&#125;&#125;组件属性(需要在双引号之内) ```html &lt;view id=&quot;item-&#123;&#123;id&#125;&#125;&quot;&gt; &lt;/view&gt; 列表渲染wx:for 在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item wx:key 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字 注意 花括号和引号之间如果有空格，将最终被解析成为字符串 条件渲染&gt; 对比 `wx-if` 与 `hidden` `wx:if` 有更高的切换消耗 `hidden` 有更高的初始渲染消耗 因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则 `wx:if` 较好。 事件 事件绑定和冒泡 bind 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡。 事件的捕获阶段 需要在捕获阶段监听事件时，可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段。 引用 import include include 可以将目标文件除了 &lt;template/&gt; &lt;wxs/&gt; 外的整个代码引入，相当于是拷贝到 include 位置]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>项目目录结构</tag>
        <tag>项目配置</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一下用 Phaser 游戏框架的开发历程]]></title>
    <url>%2F2018%2F05%2F29%2Fblockchain%2F</url>
    <content type="text"><![CDATA[Phaser]]></content>
      <categories>
        <category>Phaser</category>
        <category>游戏框架</category>
      </categories>
      <tags>
        <tag>游戏框架</tag>
        <tag>工作经历</tag>
      </tags>
  </entry>
</search>
